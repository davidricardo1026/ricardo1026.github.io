<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ansible简介</title>
    <url>/2021/10/15/ansible%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="ansible简介"><a href="#ansible简介" class="headerlink" title="ansible简介"></a>ansible简介</h1><img src="/2021/10/15/ansible%E7%AE%80%E4%BB%8B/ansible-logo.png" class="" title="ansible-logo">
<p><code>ansible</code>,<code>[ˈæn.sɪ.bəl]</code>发音,Ansible 是一个开源的基于 OpenSSH 的自动化配置管理工具。可以用它来配置系统、部署软件和编排更高级的IT任务，比如持续部署或零停机更新。<code>ansible</code>的主要目标是简单和易用，并且它还高度关注安全性和可靠性。基于这样的目标，Ansible 适用于开发人员、系统管理员、发布工程师、IT 经理，以及介于两者之间的所有人。Ansible 适合管理几乎所有的环境，从拥有少数实例的小型环境到有数千个实例的企业环境。<br>使用<code>ansible</code>无须在被管理的机器上安装代理，所以不存在如何升级远程守护进程的问题，也不存在由于卸载了守护进程而无法管理系统的问题。</p>
<h3 id="ansible工作方式"><a href="#ansible工作方式" class="headerlink" title="ansible工作方式"></a>ansible工作方式</h3><p>使用<code>ansible</code>无须在被管理的客户端电脑上安装代理之类的组件。它通过普通的 SSH 进行通信，以便从远程计算机检索信息、发出命令和复制文件。这是 Ansible 简化服务器管理的一种方式。任何公开 SSH 端口的服务器都可以通过 Ansible 进行配置和管理。</p>
<p><code>ansible</code>采用模块化的设计，所以非常容易扩展到各种特定的使用场景。模块可以用任何语言编写，并使用标准 JSON 进行通信。Ansible 的配置文件是用 YAML 格式编写的，因为它使用起来非常简单，并且与主流的标记语言很相似。除了通过命令行工具 Ansible 还可以通过配置脚本(Playbooks)与客户端交互。</p>
<h3 id="ansible总结"><a href="#ansible总结" class="headerlink" title="ansible总结"></a><code>ansible</code>总结</h3><p>现在云原生比较流行,k8s来管理容器,达到大规模集群的自动化运维,虽然不在一个维度,但是相比起来效率更高,<code>ansible</code>基于ssh,基于linux本身机器,相比k8s来说,更偏向于底层,所以,还是有用武之地的,如果需要自动化操作linux机器,<br><code>ansible</code>本质上来说,就是ssh的加强版,把ssh连接的机器分类,把执行的命令模块化,可编排,做抽象和封装,实现便捷的自动化运维</p>
<h2 id="ansible安装"><a href="#ansible安装" class="headerlink" title="ansible安装"></a><code>ansible</code>安装</h2><p><code>ansible</code>管理机器分为两种,一种是管理的机器,相当于跳板机,另一种是被管理的机器,因为linux服务器都安装了ssh,所以,可以认为被管理的机器是不需要什么以来的,但是管理的机器,需要安装<code>ansible</code></p>
<h3 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装<code>ansible</code></h3><p><code>ansible</code>安装,分为两种,一种是用linux发行版的pkg安装,这个基本上都有,直接安装就好了,例如<code>ubuntu</code>就是下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install software-properties-common</span><br><span class="line">sudo add-apt-repository --yes --update ppa:ansible/ansible</span><br><span class="line">sudo apt install ansible</span><br></pre></td></tr></table></figure>
<p>还有一种方式是pip安装, 因为本身<code>ansible</code>是python写的,可以用python的包管理安装,但是这种安装以后,需要一些额外的配置,所以,不推荐在服务器上安装的时候使用这种方式,<br>但是这种方式依赖少,自己电脑上装得时候,可以尝试这种方式</p>
<h2 id="ansible的hello-world"><a href="#ansible的hello-world" class="headerlink" title="ansible的hello world"></a><code>ansible</code>的hello world</h2><p><code>ansible</code>是ssh连接客户机器的,ssh连接分为两种,一种是密码,比较麻烦,也不适合自动化运维,不建议使用,一种是使用公钥登陆,而且这种安全性也高,不过需要一些额外的配置</p>
<ol>
<li>生成公钥<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 # rsa已经被废弃了,如果使用rsa,还需要使用额外的配置,非常不推荐</span><br></pre></td></tr></table></figure></li>
<li>发送到客户机器<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i $&#123;your pub file&#125; root@192.168.85.35 #使用什么用户,以及该机器的地址</span><br></pre></td></tr></table></figure></li>
<li>配置ssh,一般来说,不应该使用默认的名字,而且管理的机器一定会有很多的私钥存放,所以,必须要额外的配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 192.168.85.35</span><br><span class="line">	Hostname 192.168.85.35</span><br><span class="line">	User root</span><br><span class="line">	PreferredAuthentications publickey</span><br><span class="line">	# 如果出现 no mutual signature algorithm 错误,ssh 连接不上的时候,使用 -vvv,查看详细信息</span><br><span class="line">#   PubkeyAcceptedKeyTypes +ssh-rsa</span><br><span class="line">    IdentityFile ~/.ssh/ssh8535</span><br></pre></td></tr></table></figure></li>
<li>配置inventory文件,<code>/etc/ansible/hosts</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm8535 ansible_ssh_user=root ansible_ssh_host=192.168.85.35 ansible_ssh_port=22</span><br></pre></td></tr></table></figure></li>
<li><code>ansible</code>的hello world,看到输出如下,就表示成功<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ansible vm8535 -m ping</span></span><br><span class="line">vm8535 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;/usr/bin/python&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;changed&quot;: false,</span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ansible相关概念"><a href="#ansible相关概念" class="headerlink" title="ansible相关概念"></a><code>ansible</code>相关概念</h2><p><code>ansible</code>的主要概念分为 <code>inventory</code>,即管理那些机器,需要提前配置,<code>Playbooks</code>,是一组IT程序运行的命令集合</p>
<h3 id="inventory文件"><a href="#inventory文件" class="headerlink" title="inventory文件"></a><code>inventory</code>文件</h3><p>配置操作的主机,主机的配置,如果集合一样,可以有多个集合,集合之间还可以有并集的概念</p>
<h4 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h4><p>默认的文件地址是<code>/etc/ansible/hosts</code>,可以通过<code>/etc/ansible/ansible.cfg</code>配置,类似windows<br>的ini文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">mail.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[webservers]</span></span><br><span class="line">foo.example.com</span><br><span class="line">bar.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[dbservers]</span></span><br><span class="line">one.example.com</span><br><span class="line">two.example.com</span><br><span class="line">three.example.com</span><br></pre></td></tr></table></figure>

<p>其中还可以配置主机变量,组变量,合并组,功能比较强大,详细的官方文档在这里<br><a href="https://ansible-tran.readthedocs.io/en/latest/docs/intro_inventory.html#id7">ansible中文权威指南-inventory文件</a></p>
<p>这里在配置的时候,可以使用别名,非常方便</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">vm8535 <span class="attr">ansible_ssh_user</span>=root ansible_ssh_host=<span class="number">192.168</span>.<span class="number">85.35</span> ansible_ssh_port=<span class="number">22</span></span><br></pre></td></tr></table></figure>
<ol>
<li>这里的<code>vm8535</code>就是主机的名字,以后可以使用这个名字,而不用使用域名或者ip</li>
<li><code>ansible_ssh_user</code>默认就是你当前的用户,如果你是<code>root</code>,那就是<code>root</code>,这里沿用的是ssh的逻辑,所以,建议显式的配置</li>
<li><code>ansible_ssh_host</code>就是主机地址,也可以是域名**(&#x2F;etc&#x2F;hosts里面的配置,或者公网的域名)**</li>
<li><code>ansible_ssh_port</code>如果ssh的端口不是默认的,那么这里必须显式的配置</li>
</ol>
<p>常用的参数如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible_ssh_host</span><br><span class="line">      将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</span><br><span class="line"></span><br><span class="line">ansible_ssh_port</span><br><span class="line">      ssh端口号.如果不是默认的端口号,通过此变量设置.</span><br><span class="line"></span><br><span class="line">ansible_ssh_user</span><br><span class="line">      默认的 ssh 用户名</span><br><span class="line"></span><br><span class="line">ansible_ssh_pass</span><br><span class="line">      ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)</span><br><span class="line"></span><br><span class="line">ansible_sudo_pass</span><br><span class="line">      sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)</span><br><span class="line"></span><br><span class="line">ansible_sudo_exe (new in version 1.8)</span><br><span class="line">      sudo 命令路径(适用于1.8及以上版本)</span><br><span class="line"></span><br><span class="line">ansible_connection</span><br><span class="line">      与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &#x27;smart&#x27;,&#x27;smart&#x27; 方式会根据是否支持 ControlPersist, 来判断&#x27;ssh&#x27; 方式是否可行.</span><br><span class="line"></span><br><span class="line">ansible_ssh_private_key_file</span><br><span class="line">      ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</span><br><span class="line"></span><br><span class="line">ansible_shell_type</span><br><span class="line">      目标系统的shell类型.默认情况下,命令的执行使用 &#x27;sh&#x27; 语法,可设置为 &#x27;csh&#x27; 或 &#x27;fish&#x27;.</span><br><span class="line"></span><br><span class="line">ansible_python_interpreter</span><br><span class="line">      目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \*BSD, 或者 /usr/bin/python</span><br><span class="line">      不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).</span><br><span class="line"></span><br><span class="line">      与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....</span><br></pre></td></tr></table></figure>

<p>注意,如果不是root用户的话,会使用<code>sudo</code>命令,这里建议去服务器,把你使用的用户的<code>sudo</code>配置成,不需要密码,<br>否则的话,就失去了自动化配置的意义,每次手动输入<code>sudo</code>密码也是一件不可忍受的事情,在这里<code>/etc/sudoers</code>添加如下配置即可,无需重新启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;your_user_name&#125; ALL=(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>

<h4 id="patterns"><a href="#patterns" class="headerlink" title="patterns"></a><code>patterns</code></h4><p><code>patterns</code>就是根据<code>inventory</code>选取特定的主机,详情文档<br><a href="https://ansible-tran.readthedocs.io/en/latest/docs/intro_patterns.html#id1">Ansible中文权威指南-patterns</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible &lt;pattern_goes_here&gt; -m &lt;module_name&gt; -a &lt;arguments&gt;</span><br><span class="line">ansible webservers -m service -a &quot;name=httpd state=restarted&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">all # 全部</span><br><span class="line"></span><br><span class="line">one.example.com # 域名</span><br><span class="line">one.example.com:two.example.com # 多个域名</span><br><span class="line">192.168.1.50 # ip</span><br><span class="line">192.168.1.* # 多个ip,类似ant风格</span><br><span class="line"></span><br><span class="line">webservers #一个组</span><br><span class="line">webservers:dbservers # 多个组</span><br><span class="line"></span><br><span class="line">webservers:!phoenix # 一个组,排除</span><br><span class="line"></span><br><span class="line">webservers:dbservers:&amp;staging:!phoenix #多个组交集并排除,注意这里仅仅dbservers:&amp;staging是交集</span><br><span class="line"></span><br><span class="line">*.example.com # 多个域名</span><br><span class="line">*.com # 多个域名</span><br><span class="line"></span><br><span class="line">one*.com:dbservers # 域名和组 组合</span><br><span class="line"></span><br><span class="line">webservers[0] # 下标0,即该组第一个</span><br><span class="line">webservers[0-25] # 下标 0-25,即该组 0-25,总共26个</span><br><span class="line"></span><br><span class="line">~(web|db).*\.example\.com # 使用正则表达式的域名</span><br></pre></td></tr></table></figure>


<h3 id="Playbooks编排"><a href="#Playbooks编排" class="headerlink" title="Playbooks编排"></a><code>Playbooks</code>编排</h3><p>Playbooks 是 Ansible的配置,部署,编排语言.他们可以被描述为一个需要希望远程主机执行命令的方案,或者一组IT程序运行的命令集合.</p>
<p><a href="https://github.com/ansible/ansible-examples">playbooks配置实例</a><br>这里面有一些的例子,比如tomcat的,可以参考一下,稍微修改就能符合我们自己的需求</p>
<h4 id="playbooks基础"><a href="#playbooks基础" class="headerlink" title="playbooks基础"></a><code>playbooks</code>基础</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span> <span class="comment">#主机</span></span><br><span class="line">  <span class="attr">vars:</span> <span class="comment"># 环境变量</span></span><br><span class="line">    <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">max_clients:</span> <span class="number">200</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span> <span class="comment"># 执行用户</span></span><br><span class="line">  <span class="attr">tasks:</span> <span class="comment"># 任务</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span> <span class="comment">#名字</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">pkg=httpd</span> <span class="string">state=latest</span> <span class="comment"># action的模块名字 命令参数</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">write</span> <span class="string">the</span> <span class="string">apache</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=/srv/httpd.j2</span> <span class="string">dest=/etc/httpd.conf</span></span><br><span class="line">    <span class="attr">notify:</span> <span class="comment"># 通知</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span></span><br><span class="line">  <span class="attr">handlers:</span> <span class="comment"># 通知处理</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>
<p>完整的结构</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pre_tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">some_role</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">&#x27;still busy&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">post_tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">&#x27;goodbye&#x27;</span></span><br></pre></td></tr></table></figure>


<h4 id="playbooks-task-幂等性"><a href="#playbooks-task-幂等性" class="headerlink" title="playbooks task 幂等性"></a><code>playbooks</code> <code>task</code> 幂等性</h4><p>在运行 playbook 时（从上到下执行）,如果一个 host 执行 task 失败,这个 host 将会从整个 playbook 的 rotation 中移除. 如果发生执行失败的情况,请修正 playbook 中的错误,然后重新执行即可.</p>
<p>每个 task 的目标在于执行一个 moudle, 通常是带有特定的参数来执行.在参数中可以使用变量（variables）.</p>
<p>modules 具有”幂等”性,意思是如果你再一次地执行 moudle（译者注:比如遇到远端系统被意外改动,需要恢复原状）,moudle 只会执行必要的改动,只会改变需要改变的地方.所以重复多次执行 playbook 也很安全.</p>
<p>对于 command module 和 shell module,重复执行 playbook,实际上是重复运行同样的命令.如果执行的命令类似于 ‘chmod’ 或者 ‘setsebool’ 这种命令,这没有任何问题.也可以使用一个叫做 ‘creates’ 的 flag 使得这两个 module 变得具有”幂等”特性 （不是必要的）.</p>
<h4 id="jinja2-模板"><a href="#jinja2-模板" class="headerlink" title="jinja2 模板"></a><code>jinja2</code> 模板</h4><p><code>ansible</code>几乎所有的地方都可以引用变量,使用<code>jinja2</code>的语法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">My</span> <span class="string">amp</span> <span class="string">goes</span> <span class="string">to</span> &#123;&#123; <span class="string">max_amp_value</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">template:</span> <span class="string">src=foo.cfg.j2</span> <span class="string">dest=&#123;&#123;</span> <span class="string">remote_install_path</span> <span class="string">&#125;&#125;/foo.cfg</span></span><br></pre></td></tr></table></figure>

<h4 id="include-语句"><a href="#include-语句" class="headerlink" title="include 语句"></a><code>include</code> 语句</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">this</span> <span class="string">is</span> <span class="string">a</span> <span class="string">play</span> <span class="string">at</span> <span class="string">the</span> <span class="string">top</span> <span class="string">level</span> <span class="string">of</span> <span class="string">a</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">say</span> <span class="string">hi</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">foo</span></span><br><span class="line">    <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">&quot;hi...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include:</span> <span class="string">load_balancers.yml</span> <span class="comment"># 包含其它task</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include:</span> <span class="string">webservers.yml</span> <span class="comment"># 包含其它task</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">include:</span> <span class="string">dbservers.yml</span> <span class="comment"># 包含其它task</span></span><br></pre></td></tr></table></figure>

<h4 id="roles-定义结构"><a href="#roles-定义结构" class="headerlink" title="roles 定义结构"></a><code>roles</code> 定义结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site.yml</span><br><span class="line">webservers.yml</span><br><span class="line">fooservers.yml</span><br><span class="line">roles/</span><br><span class="line">   common/</span><br><span class="line">     files/</span><br><span class="line">     templates/</span><br><span class="line">     tasks/</span><br><span class="line">     handlers/</span><br><span class="line">     vars/</span><br><span class="line">     defaults/</span><br><span class="line">     meta/</span><br><span class="line">   webservers/</span><br><span class="line">     files/</span><br><span class="line">     templates/</span><br><span class="line">     tasks/</span><br><span class="line">     handlers/</span><br><span class="line">     vars/</span><br><span class="line">     defaults/</span><br><span class="line">     meta/</span><br></pre></td></tr></table></figure>

<p>这是playbook</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">common</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">webservers</span></span><br></pre></td></tr></table></figure>

<p>这个 playbook 为一个角色 ‘x’ 指定了如下的行为：</p>
<ol>
<li>如果 roles&#x2F;x&#x2F;tasks&#x2F;main.yml 存在, 其中列出的 tasks 将被添加到 play 中</li>
<li>如果 roles&#x2F;x&#x2F;handlers&#x2F;main.yml 存在, 其中列出的 handlers 将被添加到 play 中</li>
<li>如果 roles&#x2F;x&#x2F;vars&#x2F;main.yml 存在, 其中列出的 variables 将被添加到 play 中</li>
<li>如果 roles&#x2F;x&#x2F;meta&#x2F;main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 and later)</li>
<li>所有 copy tasks 可以引用 roles&#x2F;x&#x2F;files&#x2F; 中的文件，不需要指明文件的路径。</li>
<li>所有 script tasks 可以引用 roles&#x2F;x&#x2F;files&#x2F; 中的脚本，不需要指明文件的路径。</li>
<li>所有 template tasks 可以引用 roles&#x2F;x&#x2F;templates&#x2F; 中的文件，不需要指明文件的路径。</li>
<li>所有 include tasks 可以引用 roles&#x2F;x&#x2F;tasks&#x2F; 中的文件，不需要指明文件的路径。</li>
</ol>
<h5 id="参数化引用-role"><a href="#参数化引用-role" class="headerlink" title="参数化引用 role"></a>参数化引用 <code>role</code></h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">common</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">foo_app_instance</span>, <span class="attr">dir:</span> <span class="string">&#x27;/opt/a&#x27;</span>,  <span class="attr">port:</span> <span class="number">5000</span> &#125; <span class="comment">#两个相同的role,但是参数不一样</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">foo_app_instance</span>, <span class="attr">dir:</span> <span class="string">&#x27;/opt/b&#x27;</span>,  <span class="attr">port:</span> <span class="number">5001</span> &#125; <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>等价于以下的写法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">common</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">foo_app_instance</span></span><br><span class="line">      <span class="attr">vars:</span></span><br><span class="line">        <span class="attr">dir:</span> <span class="string">&#x27;/opt/a&#x27;</span></span><br><span class="line">        <span class="attr">app_port:</span> <span class="number">5000</span></span><br><span class="line">      <span class="attr">tags:</span> <span class="string">typeA</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">foo_app_instance</span></span><br><span class="line">      <span class="attr">vars:</span></span><br><span class="line">        <span class="attr">dir:</span> <span class="string">&#x27;/opt/b&#x27;</span></span><br><span class="line">        <span class="attr">app_port:</span> <span class="number">5001</span></span><br><span class="line">      <span class="attr">tags:</span> <span class="string">typeB</span></span><br></pre></td></tr></table></figure>

<h2 id="ansible实践"><a href="#ansible实践" class="headerlink" title="ansible实践"></a><code>ansible</code>实践</h2><p>这里假设要部署一个java的项目,安装jdk,copy jar文件,copy 脚本來实践</p>
<p>项目结构如下,完全按照<code>roles</code>的规范来</p>
<img src="/2021/10/15/ansible%E7%AE%80%E4%BB%8B/project_structure.png" class="" title="project_structure">

<p><code>site.yml</code>内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">plb_servers</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>

<p><code>main.yml</code>内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Make</span> <span class="string">home</span> <span class="string">dir</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;home_dir&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">jdk</span></span><br><span class="line">  <span class="attr">copy:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">jdk-8u291-linux-x64.tar.gz</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;home_dir&#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Extract</span> <span class="string">jdk</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">chdir=&#123;&#123;home_dir&#125;&#125;</span> <span class="string">/bin/tar</span> <span class="string">xvf</span> <span class="string">jdk-8u291-linux-x64.tar.gz</span> <span class="string">-C</span> <span class="string">.</span> <span class="string">creates=jdk1.8.0_291</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">fat</span> <span class="string">jar</span></span><br><span class="line">  <span class="attr">copy:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;exec_jar_name&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;home_dir&#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">start</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">start.sh</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;home_dir&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">stop</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">stop.sh</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;home_dir&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">ehcache</span> <span class="string">config</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">src:</span> <span class="string">ehcache.xml</span></span><br><span class="line">    <span class="attr">dest:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;home_dir&#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Make</span> <span class="string">ehcache</span> <span class="string">dir</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;home_dir&#125;&#125;</span>/ehcache&quot;</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">app</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">cmd:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;home_dir&#125;&#125;</span>/start.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#- name: wait for app to start</span></span><br><span class="line"><span class="comment">#  wait_for:</span></span><br><span class="line"><span class="comment">#    port: &quot;&#123;&#123;http_port&#125;&#125;&quot;</span></span><br><span class="line"><span class="comment">#    timeout: 12</span></span><br></pre></td></tr></table></figure>

<h2 id="aisible注意事项"><a href="#aisible注意事项" class="headerlink" title="aisible注意事项"></a><code>aisible</code>注意事项</h2><h3 id="yaml的jinja2陷阱"><a href="#yaml的jinja2陷阱" class="headerlink" title="yaml的jinja2陷阱"></a><code>yaml</code>的<code>jinja2</code>陷阱</h3><p>yaml语法不能<code>&#123;</code>开头,所以如果开头使用<code>jinja2</code>语法,应该要注意</p>
<p>错误</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">app_servers</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">      <span class="attr">app_path:</span> &#123;&#123; <span class="string">base_path</span> &#125;&#125;<span class="string">/22</span></span><br></pre></td></tr></table></figure>
<p>正确</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">app_servers</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">       <span class="attr">app_path:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; base_path &#125;&#125;</span>/22&quot;</span></span><br></pre></td></tr></table></figure>

<div style="display: none">
### db操作

<p><code>ansible</code>执行db操作,这里要区分,不同的数据库,如mysql还是oracle,还是postgresql,每个都需要使用不同的插件,而且需要不同的依赖,所以,要求还是比较高的,尤其是<br>oracle,因为不是开源的,所以,没有社区支持,比较麻烦</p>
<p>所以,如果使用<code>ansible</code>来执行db操作,相对于来说麻烦一些,这里可以考虑在应用中,执行操作,可选的方案有<code>flyway</code></p>
</div>

<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>脚本应该按照幂等性的原则来说,前面也提到过,也就是,中间任意一个步骤失败,不用去服务器删除文件之类的,直接重新执行即可,如果你使用<code>ansible</code>本身的模块,那么大部分<br>情况下,你是不用考虑幂等性的,但是如果你执行的是自己的脚本,如shell命令,这里你可能需要额外的使用<code>creates</code>来完成幂等性</p>
<div style="display: none">
### shell后台任务陷阱

<p><code>ansible</code>本身通过包装ssh命令来执行<code>shell</code>脚本,所以,执行完以后,便会退出,所以,如果你需要执行后台任务,你需要使用<code>setsid</code>或者<code>nohup</code>来确保你的任务<br>不会被中断,这个你需要写在脚本里面,否则,基本就是刚执行,就中断,几乎就像没执行一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export LANG=zh_CN.UTF-8</span><br><span class="line">setsid &#123;&#123;home_dir&#125;&#125;/jdk1.8.0_291/bin/java -jar &#123;&#123;home_dir&#125;&#125;/&#123;&#123;exec_jar_name&#125;&#125; &gt; all.log 2 &gt;&amp; 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不加setsid,那么java启动以后,立马被<span class="built_in">kill</span>,只会看到一个空的all.log文件</span></span><br></pre></td></tr></table></figure>
</div>
]]></content>
      <categories>
        <category>运维工具</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSuchMethodError的bug修复</title>
    <url>/2021/11/15/NoSuchMethodError%E7%9A%84bug%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="记一次NoSuchMethodError"><a href="#记一次NoSuchMethodError" class="headerlink" title="记一次NoSuchMethodError"></a>记一次<code>NoSuchMethodError</code></h1><p><code>NoSuchMethodError</code>的就有类找到了,但是方法没有,所以,思路主要有两个</p>
<ol>
<li>找错了类,也就是有同名类,一般不会有同名类,出现同名类的场景比较少,这里列举一个.比如<code>guava</code>,和<code>google-collections</code>,两个jar,但是命名空间一样,<br>里面有些类重复了,没错,<code>google-collections</code>废弃了,然后<code>guava</code>一直在维护,类加载顺序本身存在不确定性,所以<code>guava</code>用到了<code>google-collections</code>的<br>类,这样就不行了,这种比较奇怪,定位也很麻烦.那个方法出错了,可以自己写一下,然后debug要进去的时候,ide就会提示你重复,才能定位</li>
<li>类没找错,但是版本不对,这种比较常见,就是多个lib协同的问题,比如<code>hive</code>用了新的<code>guava</code>,但是你是老版的<code>guava</code>,有这个类,但是没这个方法,所以需要<br>妥善处理好类之间的协同关系,这里,<code>springBoot</code>就出现了<code>dependencyManagement</code>,来缓解这个情况</li>
</ol>
<p>总结下来,就是类有,但是要么重名,要么版本不对,主要分这两个情况需要注意</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>camunda常见功能解析</title>
    <url>/2023/03/21/camunda%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="camunda常见功能解析"><a href="#camunda常见功能解析" class="headerlink" title="camunda常见功能解析"></a>camunda常见功能解析</h1><p>从camunda desktop modeler的角度来分析一下,camunda到底有那些功能</p>
<h2 id="一些重要的概念"><a href="#一些重要的概念" class="headerlink" title="一些重要的概念"></a>一些重要的概念</h2><h3 id="external-task"><a href="#external-task" class="headerlink" title="external task"></a>external task</h3><p>类似用户任务,设计的意图,比如可以调用外部系统,但是和用户任务的设计意图不一样,只是使用方式一样</p>
<h3 id="job-execution"><a href="#job-execution" class="headerlink" title="job execution"></a>job execution</h3><p>当一个time event发起,或者当一个任务被标记成异步以后,它就变成了job,成为了job,以后,有以下的优点</p>
<ol>
<li>非阻塞,任务可以继续执行</li>
<li>增加了重试的机制</li>
</ol>
<h3 id="Asynchronous-Continuations"><a href="#Asynchronous-Continuations" class="headerlink" title="Asynchronous Continuations"></a>Asynchronous Continuations</h3><p><a href="https://camunda.com/blog/2014/07/advanced-asynchronous-continuations/">一篇很好的解释</a></p>
<img src="/2023/03/21/camunda%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/async.png" class="" title="异步任务">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AFTER (new) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;service1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Generate Invoice&quot;</span> <span class="attr">camunda:asyncAfter</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">camunda:class</span>=<span class="string">&quot;my.custom.Delegate&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- BEFORE --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;service1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Generate Invoice&quot;</span> <span class="attr">camunda:asyncBefore</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">camunda:class</span>=<span class="string">&quot;my.custom.Delegate&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>before</p>
<ol>
<li>非阻塞,异步执行,主要用于创建异步的任务,还可以重试</li>
</ol>
<p>after</p>
<ol>
<li>创建安全点,防止任务失败没有记录,而且也可以重试</li>
</ol>
<h3 id="execution-listeners"><a href="#execution-listeners" class="headerlink" title="execution listeners"></a>execution listeners</h3><p>类似前面一样的存在,可以看到,而且可以加到任何地方,比如事件,任务,还有流程里面</p>
<img src="/2023/03/21/camunda%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/execution_listeners.png" class="" title="流程面板">

<ol>
<li><code>event type</code>,只有start 和 end,可以有多个,按照顺序来,好像是start前面的先执行,然后end前面的后面执行</li>
<li><code>listener type</code>有java class,expression,delegate expression,script</li>
<li>expression 就是value的意思,根据你填的类型,来填,比如是java calss,就是java全类名,如果和spring集成了,还可以是spring的bean,这里需要选择类型是delegate expression</li>
<li>字段注入的名字,java使用的时候,类似自动注入 <a href="https://docs.camunda.org/manual/latest/user-guide/process-engine/delegation-code/#field-injection">字段注入的文档</a></li>
<li>字段注入的类型,可以是string或者是expression</li>
<li>字段注入的值</li>
</ol>
<h3 id="task-listeners"><a href="#task-listeners" class="headerlink" title="task listeners"></a>task listeners</h3><p>和execution listeners不一样,task listeners专门用于task任务<br><a href="https://docs.camunda.org/manual/latest/user-guide/process-engine/delegation-code/#task-listener">task listener文档</a></p>
<img src="/2023/03/21/camunda%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/task_listeners.png" class="" title="任务监听器">

<ol>
<li>event type,相比execution listeners,非常多,create assignment complete delete update timeout</li>
<li>可选的id,相比execution listeners,有自己的id</li>
<li>这个和execution listeners 类似</li>
<li>也和execution listener类似</li>
</ol>
<h3 id="inputs-and-outputs"><a href="#inputs-and-outputs" class="headerlink" title="inputs and outputs"></a>inputs and outputs</h3><p>多了一种机制存在,让业务更灵活,input只有当前task可以获取,然后output,可以当前以后的task可以获取,而且input和output在多实例的时候,特别有效<br><a href="https://docs.camunda.org/manual/7.10/user-guide/process-engine/variables/#input-output-variable-mapping">camunda文档</a></p>
<ol>
<li>只有当前task只能获取input</li>
<li>output当前之后的task都可以获取</li>
<li>和普通上下文的变量获取没有什么区别,都是用名字获取</li>
<li>多实例的时候特别有效</li>
<li>可以放string,expression,还可以放list和map</li>
</ol>
<h2 id="组件panel"><a href="#组件panel" class="headerlink" title="组件panel"></a>组件panel</h2><h3 id="流程panel"><a href="#流程panel" class="headerlink" title="流程panel"></a>流程panel</h3><img src="/2023/03/21/camunda%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/process_panel.png" class="" title="流程面板">

<ol>
<li>名字这里更像是一个简短的描述,只起到文档的作用</li>
<li>id在这里必须是唯一,可以用来启动流程,启动流程的时候,是<code>runtimeService.startProcessInstanceByKey(id)</code></li>
<li><code>version tag</code>类似于git的tag功能,相当于语义化的版本,而且执行的时候还可以根据<code>version tag</code>来选择版本,成为了机制</li>
<li><code>executable</code>表示流程是否可以执行,如果配置了自动扫描流程,那么不是<code>executable</code>就不会被解析</li>
<li>文档,就是描述,是语义性质的东西</li>
<li><code>time to live</code>,应该是history的cleanup,类似TTL</li>
<li><code>startable</code>表示是否作为顶级流程,因为它的web应用,会只能启动<code>startable</code>的应用,否则只能作为子流程调用</li>
<li>只有该组的用户才能启动这个流程,类似所有权</li>
<li>只有该用户才能启动这个流程,类似所有权</li>
<li><code>external task</code>的优先级,<code>external task</code>类似<code>userTask</code>,但是应用的场景不一样</li>
<li><code>job execution</code>优先级</li>
</ol>
<h3 id="start-event的panel"><a href="#start-event的panel" class="headerlink" title="start event的panel"></a>start event的panel</h3><img src="/2023/03/21/camunda%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/start_event_panel.png" class="" title="开始事件面板">

<ol>
<li>名字</li>
<li>id</li>
<li>表单</li>
<li><code>start initiator</code>流程发起人,可以是固定值,也可以是变量,然后可以通过api来获取</li>
<li>异步设置</li>
</ol>
<h3 id="user-task的panel"><a href="#user-task的panel" class="headerlink" title="user task的panel"></a>user task的panel</h3><p>用户任务,就是留白任务,走到这里会阻塞,然后调用相关api完成即可,本意是只让用户审批,工作流的审批节点几乎都是用户任务</p>
<ol>
<li>id</li>
<li>文档</li>
<li>用户任务分配,分配人员 <a href="https://camunda.com/blog/2020/05/camunda-bpm-user-task-assignment-based-on-a-dmn-decision-table/">用户任务分配</a></li>
<li>可选组</li>
<li>可选用户</li>
<li>到期时间,过期了,会产生timeout事件,可以实现自己的逻辑</li>
<li>用途为止,根据 <a href="https://forum.camunda.io/t/follow-up-date-best-practices/6114/2">camunda论坛</a>的答案, 可以过滤使用</li>
<li>优先级</li>
<li>表单,可以和表单绑定</li>
<li>input</li>
<li>output</li>
</ol>
<h3 id="service-task的panel"><a href="#service-task的panel" class="headerlink" title="service task的panel"></a>service task的panel</h3><p>服务任务,就是干活的任务,相比于用户任务,是阻塞任务,服务任务是自动任务</p>
<img src="/2023/03/21/camunda%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/service_task_panel.png" class="" title="服务任务面板">

<ol>
<li>name</li>
<li>id,不能重复</li>
<li>文档</li>
<li>implemention,type,一共有五种,分别是external,java class,expression,delegate expression,connector</li>
<li>value,分别不同的类型,填不同的值</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实camunda的desktop modeler已经涵盖了大部分camunda的常见功能,已经足够用了</p>
]]></content>
      <categories>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>camunda</tag>
      </tags>
  </entry>
  <entry>
    <title>detaease源码修改直接部署</title>
    <url>/2021/09/30/detaease%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E7%9B%B4%E6%8E%A5%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="dataease-部署"><a href="#dataease-部署" class="headerlink" title="dataease 部署"></a><code>dataease </code>部署</h1><h2 id="dataease部署简介"><a href="#dataease部署简介" class="headerlink" title="dataease部署简介"></a><code>dataease</code>部署简介</h2><p>官方给的在线部署方式,看似非常简单,其实是写的bash脚本,通过安装</p>
<p><code>docker</code>,<code>docker-compose</code>等一系列工具,执行脚本来操作的,屏蔽了很多细节,而且linux本身又分了很多发行版,所以,很容易有一些隐形的坑,而且在线安装非常耗时,所以,这里采用了直接下载源码,修改部分配置,改成使用可执行jar的方式启动,回归传统的方式,简单有效</p>
<p><strong>本文档基于当时的最新版v1.2.2,不是该版本的时候,仅供参考</strong></p>
<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><h3 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1. 下载源码"></a>1. 下载源码</h3><ol>
<li>下载源码</li>
<li><code>checkout tag</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:dataease/dataease.git</span><br><span class="line">git checkout v1.2.2</span><br></pre></td></tr></table></figure>

<h3 id="2-准备编译环境"><a href="#2-准备编译环境" class="headerlink" title="2. 准备编译环境"></a>2. 准备编译环境</h3><p>因为<code>dataease</code>使用的<code>pentaho-kettle</code>相关系列的jar,不在maven中央仓库,所以需要设置额外的<code>profile</code>,来下载相关的jar</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>omni<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>omniMaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://nexus.pentaho.org/content/groups/omni<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意<code>mvn</code>使用的时候,不要忘记增加参数增加<code>-P omni</code>来使该<code>profile起效</code></p>
<h3 id="3-编译代码"><a href="#3-编译代码" class="headerlink" title="3. 编译代码"></a>3. 编译代码</h3><p>执行一下命令编译,第一次编译非常慢,下载下载<code>node</code>,并且执行<code>npm install</code>,还要下载大量的jar,非常耗时</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure>

<h3 id="4-需要修改的配置"><a href="#4-需要修改的配置" class="headerlink" title="4. 需要修改的配置"></a>4. 需要修改的配置</h3><h4 id="4-1-获取dataease-properties文件"><a href="#4-1-获取dataease-properties文件" class="headerlink" title="4.1 获取dataease.properties文件"></a>4.1 获取<code>dataease.properties</code>文件</h4><p>下载在线安装包,解压以后,在<code>dataease/templates/</code>目录找到<code>dataease.properties</code>文件,复制到项目的<code>backend/src/main/resources</code>下面,里面的<code>spring.datasource</code>相关的就是该应用使用的数据库配置,其余的可以暂时忽略</p>
<h4 id="4-2-修改io-dataease-Application配置"><a href="#4-2-修改io-dataease-Application配置" class="headerlink" title="4.2 修改io.dataease.Application配置"></a>4.2 修改<code>io.dataease.Application</code>配置</h4><p>修改<code>value</code>为<code>classpath:dataease.properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:dataease.properties&quot;&#125;, encoding = &quot;UTF-8&quot;, ignoreResourceNotFound = true)</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-修改io-dataease-config-WebMvcConfig配置"><a href="#4-3-修改io-dataease-config-WebMvcConfig配置" class="headerlink" title="4.3 修改io.dataease.config.WebMvcConfig配置"></a>4.3 修改<code>io.dataease.config.WebMvcConfig</code>配置</h4><ol>
<li><p>复制<code>mapFiles</code>文件夹到<code>backend/src/main/resources</code>目录</p>
</li>
<li><p>修改<code>io.dataease.config.WebMvcConfig</code>类,<code>value</code>改为<code>classpath:mapFiles/full/</code>.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;geo.rootpath:classpath:mapFiles/full/&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String geoPath;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-修改ehcache-xml的引用位置"><a href="#4-4-修改ehcache-xml的引用位置" class="headerlink" title="4.4 修改ehcache.xml的引用位置"></a>4.4 修改<code>ehcache.xml</code>的引用位置</h4><p><code>ehcache.xml</code>的<code>diskStore</code>改成线上存在的位置,否则回报错,需要提前修改,因为打包成可执行jar以后,就不好修改了</p>
<h4 id="4-5-generatorConfig-xml修改"><a href="#4-5-generatorConfig-xml修改" class="headerlink" title="4.5 generatorConfig.xml修改"></a>4.5 <code>generatorConfig.xml</code>修改</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">url</span>=<span class="string">&quot;classpath:dataease.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.6 <code>logback.xml</code>修改</p>
<p>删除下面一行,直接使用<code>application.properties</code>的配置,</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">file</span>=<span class="string">&quot;/opt/dataease/conf/dataease.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>总共有三个引用,其中只有<code>$&#123;logger.level:INFO&#125;</code>有默认值,其余都没有,需要自己配置,直接配置到<code>application.properties</code>文件里面</p>
<ol>
<li><code>$&#123;logging.file.path&#125;</code></li>
<li><code>$&#123;logger.level:INFO&#125;</code></li>
<li><code>$&#123;logger.sql.level&#125;</code></li>
</ol>
<h3 id="5-重新编译"><a href="#5-重新编译" class="headerlink" title="5. 重新编译"></a>5. 重新编译</h3><p>重新编译即可,<code>backend</code>项目<code>target</code>目录会生成一个<code>backend-1.2.0.jar</code>,这个就是<code>spring boot</code>的可执行jar,可以直接部署</p>
<h3 id="6-配置专用数据库"><a href="#6-配置专用数据库" class="headerlink" title="6. 配置专用数据库"></a>6. 配置专用数据库</h3><p>因为<code>dataease</code>项目使用了一些额外的功能,所以数据库的配置必须满足一下要求,如果原来的数据库已经满足,可以忽略,不满足,建议<code>docker</code>新建一个数据库,专门给<code>dataease</code>使用</p>
<ol>
<li><code>lower_case_table_names=1</code>不区分大小写</li>
<li><code>group_concat_max_len=1024000</code>尽可能的数值非常大</li>
<li><code>sql_mode</code>去掉<code>only_full_group_by</code>,以mysql8.0.26为例,去掉<code>only_full_group_by</code>以后,这样配置<code>sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</code></li>
</ol>
<h3 id="7-配置默认数据源"><a href="#7-配置默认数据源" class="headerlink" title="7. 配置默认数据源"></a>7. 配置默认数据源</h3><p>用户有两个,一个是<code>admin</code>,一个是<code>demo</code>,密码默认都是<code>dataease</code>,登陆以后,会发现默认的数据源配置不对,因为我们不是docker的方式部署,数据库用的是我们自己的配置,所以,可以新建一个数据源,填写我们数据库的配置,然后到数据库<code>datasource</code>表,把<code>configuration</code>字段,复制到’demo’记录那一行,这样,所有的预览就可以正常起效了</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>dataease</tag>
      </tags>
  </entry>
  <entry>
    <title>hazelcast-management-center控制中心简介</title>
    <url>/2022/12/09/hazelcast-management-center%E6%8E%A7%E5%88%B6%E4%B8%AD%E5%BF%83%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="hazelcast-management-center控制中心简介"><a href="#hazelcast-management-center控制中心简介" class="headerlink" title="hazelcast-management-center控制中心简介"></a>hazelcast-management-center控制中心简介</h1><p>hazelcast和ignite一样,为了可视化操作,都自带了控制中心一样的东西</p>
<img src="/2022/12/09/hazelcast-management-center%E6%8E%A7%E5%88%B6%E4%B8%AD%E5%BF%83%E7%AE%80%E4%BB%8B/dashdobard.png" class="" title="dashboard">

<h2 id="配置控制中心"><a href="#配置控制中心" class="headerlink" title="配置控制中心"></a>配置控制中心</h2><p>配置控制中心所在的地址即可,可以配多个,否则manager-center无法连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HazelcastConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HazelcastInstance <span class="title function_">hazelCastConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">ManagementCenterConfig</span> <span class="variable">managementCenterConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManagementCenterConfig</span>();</span><br><span class="line">        managementCenterConfig.addTrustedInterface(<span class="string">&quot;192.168.50.233&quot;</span>); <span class="comment">//可以配置多个</span></span><br><span class="line">        config.setManagementCenterConfig(managementCenterConfig);</span><br><span class="line">        config.setInstanceName(<span class="string">&quot;dev1&quot;</span>);</span><br><span class="line">        <span class="type">JetConfig</span> <span class="variable">jetConfig</span> <span class="operator">=</span> config.getJetConfig();</span><br><span class="line">        jetConfig.setEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> Hazelcast.newHazelcastInstance(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>management-center主要是可视化的查看集群的各个节点的情况,然后查看里面的数据,而且还支持各种监视的参数,以及各种查询,方便监视和排查问题</p>
<h3 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h3><img src="/2022/12/09/hazelcast-management-center%E6%8E%A7%E5%88%B6%E4%B8%AD%E5%BF%83%E7%AE%80%E4%BB%8B/menu.png" class="" title="菜单">

<ol>
<li>集群里面各种信息,成员,客户端,健康检查等等</li>
<li>存储的各种信息,比如maps等常见的数据类型</li>
<li>接下来是一些流的信息</li>
<li>计算的信息</li>
<li>消息的信息</li>
<li>cp子系统的信息,应该是一些内部的自省机制,比如锁和引用之类的,默认是关闭,需要手动开启</li>
</ol>
<h3 id="控制台和sql查询"><a href="#控制台和sql查询" class="headerlink" title="控制台和sql查询"></a>控制台和sql查询</h3><p>sql默认开启,但是控制台需要节点的支持,手动配置生效</p>
<ol>
<li>hazelcast是支持sql语法的</li>
<li>hazelcast的命令行同时也支持一些命令</li>
</ol>
<img src="/2022/12/09/hazelcast-management-center%E6%8E%A7%E5%88%B6%E4%B8%AD%E5%BF%83%E7%AE%80%E4%BB%8B/sql.png" class="" title="sql支持">
<img src="/2022/12/09/hazelcast-management-center%E6%8E%A7%E5%88%B6%E4%B8%AD%E5%BF%83%E7%AE%80%E4%BB%8B/cmd.png" class="" title="命令行支持">

<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>这里的设置,主要针对的是用户设置,可以看到,management-center不但支持间的用户名和密码,还支持集成,ladp,saml等第三方认证</p>
<img src="/2022/12/09/hazelcast-management-center%E6%8E%A7%E5%88%B6%E4%B8%AD%E5%BF%83%E7%AE%80%E4%BB%8B/settings.png" class="" title="用户设置">]]></content>
      <categories>
        <category>缓存</category>
        <category>分布式缓存</category>
        <category>hazelcast</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>hazelcast入门使用</title>
    <url>/2022/12/08/hazelcast%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="hazelcast入门使用"><a href="#hazelcast入门使用" class="headerlink" title="hazelcast入门使用"></a>hazelcast入门使用</h1><p>hazelcast本来就是个java项目,所以,hazelcast的团队写了代码以后,打成jar,如果加个启动,就是独立的程序,如果采用jar依赖的方式,就是嵌入式部署,这个很好理解的</p>
<ol>
<li>嵌入式部署,相对来说,减少网络开销,速度更快一些,但是如果挂了,会一起挂,</li>
<li>独立部署,独立性更好,比较隔离</li>
<li>角色区别,hazelcast还可以分为server和client,client不会存储数据和修改数据</li>
</ol>
<h2 id="嵌入式部署"><a href="#嵌入式部署" class="headerlink" title="嵌入式部署"></a>嵌入式部署</h2><p>嵌入式部署比较方便,而且因为是一个jvm速度上是有优势的,hazelcast的api变化幅度还是比较大的,所以,网上的资料都已经不适用了,只能自己去官网看资料,<br>这是地址<a href="https://docs.hazelcast.com/hazelcast/latest/getting-started/install-hazelcast">官网文档地址</a><br>,里面有全文搜索,虽然hazelcast有spring-boot-starter,但是开发的进度比较慢,比如<br>5.2.1已经发布了,但是starter还没发布,所以,这里的演示不用starter</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.hazelcast:hazelcast-spring:5.2.1&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.hazelcast:hazelcast:5.2.1&#x27;</span> <span class="comment">//hazelcast-spring依赖的hazelcast版本竟然不对,需要自己显式依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HazelcastConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HazelcastInstance <span class="title function_">hazelCastConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.setInstanceName(<span class="string">&quot;dev1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Hazelcast.newHazelcastInstance(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实hazel已经有了很多默认的配置,比如他的组播地址是224.2.2.3,它是开源的,结合这文档,然后看看代码,基本就差不多了</p>
<img src="/2022/12/08/hazelcast%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/HazelcastInstance_api.png" class="" title="HazelcastInstance_api">

<p>Hazelcast提供开箱即用的分布式数据结构，如Map，Queue，MultiMap，Topic，Lock和Executor。就是这个HazelcastInstance提供的,hazelcast也提供了分布式锁</p>
<img src="/2022/12/08/hazelcast%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/HazelcastCacheManager.png" class="" title="HazelcastCacheManager">

<p>以上的api方式使用hazelcast,还可以和spring cache结合,声明式的使用</p>
<h2 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署"></a>独立部署</h2><p>从图可以看出来,主要是两种,一个是zip,一个是zip slim,slim就是瘦身的意思,这个说法挺流行,不过不直观,其它的项目,可能会用without<br>jdk这种说法,所以,一般下载slim即可,<br>因为基本上环境都自带jdk了,不过jdk有400m了,可能还带了一些别的东西吧,比如源码,文档之类的东西,有兴趣的可以下载下来看看</p>
<img src="/2022/12/08/hazelcast%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/download_platform.png" class="" title="download_platform">

<p>下载以后,解压以后,这样子</p>
<img src="/2022/12/08/hazelcast%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/root_folder.png" class="" title="总文件夹">

<p>可以看出来,很传统的样子,bin config lib这些都是一些中间件常见的目录结构</p>
<img src="/2022/12/08/hazelcast%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/bin_folder.png" class="" title="bin文件夹">

<p>bat和sh都有,start和stop都有</p>
<img src="/2022/12/08/hazelcast%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/config_folder.png" class="" title="配置文件夹">

<p>里面给出了一些配置,而且还带实例,里面的配置,也都是有注释,是xml的形式,对应的还是那些配置</p>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>集群部署有两种形式</p>
<ol>
<li>使用组播</li>
<li>第一个节点,比如填写所有节点的ip,新加入的节点不必知道所有的节点,但是至少要知道并连接到一个已经启动的集群节点</li>
</ol>
<h3 id="组播协议（Multicast）组建集群"><a href="#组播协议（Multicast）组建集群" class="headerlink" title="组播协议（Multicast）组建集群"></a>组播协议（Multicast）组建集群</h3><p>在使用组播协议（Multicast）作为自动组建集群机制时，集群中的成员不需要知道其他成员的详细地址（IP），他们仅仅是通过组播将信号广播到其他成员的监听端口中。使用之前确保网络环境支持<br>Multicast。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">network</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">join</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">multicast</span> <span class="attr">enabled</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">multicast-group</span>&gt;</span>224.2.2.3<span class="tag">&lt;/<span class="name">multicast-group</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">multicast-port</span>&gt;</span>54327<span class="tag">&lt;/<span class="name">multicast-port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">multicast-time-to-live</span>&gt;</span>32<span class="tag">&lt;/<span class="name">multicast-time-to-live</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">multicast-timeout-seconds</span>&gt;</span>2<span class="tag">&lt;/<span class="name">multicast-timeout-seconds</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">trusted-interfaces</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">interface</span>&gt;</span>192.168.1.102<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">trusted-interfaces</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">multicast</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tcp-ip</span> <span class="attr">enabled</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tcp-ip</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aws</span> <span class="attr">enabled</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aws</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">join</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组网功能的配置由 <join> 及其子元素来确定。其中 <multicast> 元素用来配置 组播协议 组网的相关参数。当设置 <multicast> 元素中 enabled 属性为 true 时，表示启用 组播协议 组网。下面将详细说明每一个参数：</p>
<ol>
<li>enabled：<code>[true|false]</code>，指定是否使用组播协议来组建集群。</li>
<li>multicast-group：组播分组的IP地址。当要创建同一个网段的集群时，需要配置这个参数。取值范围从224.0.0.0到239.255.255.255，默认224.2.2.3。</li>
<li>multicast-port：组播协议启用套接字的端口（socket port），这个端口用于Hazelcast监听外部发送来的组网请求。默认54327。</li>
<li>multicast-time-to-live：组播协议发送包的生存时间周期（TTL）。可以从 协议官方文档 详细了解 组播协议的TTL。</li>
<li>multicast-timeout-seconds：当节点启动后，这个参数（单位：秒）指定了当前节点等待其他节点响应的时间周期。例如，设置为60秒时，每一个节点启动后通过组播协议广播消息，如果主节点在60秒内返回响应消息，则新启动的节点加入这个主节点所在的集群，如果设定时间内没有返回消息，那么节点会把自己设置为一个主节点，并创建新的集群（主节点可以理解为集群的第一个节点）。默认值为2秒。</li>
<li>trusted-interfaces：可信任成员的IP地址。当一个节点试图加入集群，如果其不是一个可信任节点，他的加入请求将被拒绝。可以在IP的最后一个数字上使用通配符（<em>）来设置一个IP范围（例如：192.168.1.</em> 或192.168.1.100-110）。</li>
</ol>
<h3 id="TCP协议组建集群"><a href="#TCP协议组建集群" class="headerlink" title="TCP协议组建集群"></a>TCP协议组建集群</h3><p>除了使用 组播协议，还可以使用TCP&#x2F;IP协议来组建集群。当使用TCP&#x2F;IP来组建新集群时，第一个节点必须将所有要加入集群的节点IP地址添加到对应列表中。在集群已经运行之后，新加入的节点不必知道所有的集群节点，但是至少要知道并连接到一个已经启动的集群节点。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hazelcast</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">network</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">join</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">multicast</span> <span class="attr">enabled</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">multicast</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tcp-ip</span> <span class="attr">enabled</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">required-member</span>&gt;</span>192.168.1.104<span class="tag">&lt;/<span class="name">required-member</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">member</span>&gt;</span>192.168.1.104<span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">members</span>&gt;</span>192.168.1.105,192.168.1.106<span class="tag">&lt;/<span class="name">members</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">connection-timeout-seconds</span>&gt;</span>60<span class="tag">&lt;/<span class="name">connection-timeout-seconds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tcp-ip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">join</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">network</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hazelcast</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出使用TCP&#x2F;IP组建网络涉及的配置参数并不多。首先需要将<tcp-ip>元素中的enabled属性设置为true表示启用TCP&#x2F;IP协议来组网。然后每个元素对应的含义如下</p>
<ol>
<li>required-member：加入集群的成员IP地址，只有这些IP地址的成员存在时集群才会组建。也就是说如果要当前节点加入集群，必须<required-member>元素中的指定的IP地址已经有集群节点先启动了，该节点才能启动，可以用于限制节点的启动顺序。</li>
<li>member：成员的IP地址。指定要加入集群的成员IP地址，这些IP地址中的成员会相互发现对方。</li>
<li>members：member的复数形态。在元素中可以使用逗号（“,”）分割多个IP地址。还可以使用-或*等符号来表达多个IP地址。</li>
<li>connection-timeout-seconds：定义连接超时时间。Hazelcast尝试连接到一个已知的节点（member元素指定）的最大超时时间，如果在指定时间内连接失败，将会放弃连接。当参数设置太小时，可能会导致一个成员可能无法连接到集群。设置太高时，成员启动的等待时间会比较久，因为当某些<member>元素标记的节点未启动时，需要花费较多时间等待。如果有较多的不同IP地址的成员需要加入集群，可以适当增加这个值，以保证所有的成员可以正确加入集群。默认值为5。</li>
</ol>
]]></content>
      <categories>
        <category>缓存</category>
        <category>分布式缓存</category>
        <category>hazelcast</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>flyway简介</title>
    <url>/2021/10/27/flyway%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>本文基于springboot2集成使用</strong></p>
<h3 id="flyway是什么"><a href="#flyway是什么" class="headerlink" title="flyway是什么"></a>flyway是什么</h3><p>flyway是一款开源的资料库版本管理工具，它更倾向于规约优于配置的方式。<br>flyway可以独立于应用实现管理并跟踪资料库变更，支援资料库版本自动升级，并且有一套预设的规约，<br>不需要复杂的配置。Migrations可以写成SQL指令码，也可以写在Java程式码中，不仅支援Command Line和Java API，<br>还支援Build构建工具和Spring Boot等。同时在分散式环境下能够安全可靠地升级资料库，同时也支援失败恢复等。</p>
<h3 id="为什么要使用Flyway"><a href="#为什么要使用Flyway" class="headerlink" title="为什么要使用Flyway"></a>为什么要使用Flyway</h3><ol>
<li>自己写的SQL忘了在所有环境执行；</li>
<li>别人写的SQL我们不能确定是否都在所有环境执行过了；</li>
<li>有人修改了已经执行过的SQL，期望再次执行；</li>
<li>需要新增环境做数据迁移；</li>
<li>每次发版需要手动控制先发DB版本，再发布应用版本；</li>
<li>…</li>
</ol>
<h2 id="flyway工作原理"><a href="#flyway工作原理" class="headerlink" title="flyway工作原理"></a>flyway工作原理</h2><p>一言以蔽之：flyway通过历史记录表（flyway_schema_history）来记录版本历史。<br>每次随专案启动时将会自动扫描在resources&#x2F;db&#x2F;migration下的档案并查询flyway_schema_history判断是否为新增档案。<br>如果是新增的档案，则执行该迁移档案。如果不是，则忽略。</p>
<ol>
<li>当flyway在一个空资料库执行时，它将直接建立一张预设名为flyway_schema_history的资料记录为空的历史记录表，这张表将被用来跟踪或记录资料库的状态。</li>
<li>flyway将会开始扫描文件系统或专案classpath路径下的迁移档案。flyway按版本号顺序排列迁移档案，并按序执行，并更新历史记录表中的内容</li>
<li>当专案再次发版时，flyway会再次扫描迁移档案，然后将迁移文的版本号与历史记录表中的版本号进行对比。<br>flyway会忽略版本号小于等于表中当前最大版本的迁移档案，剩余待执行迁移档案会按版本号升序执行。</li>
</ol>
<p><strong>并非真正忽略，而是会校验checksum值是否一致，以此来保证历史版本档案未被篡改</strong></p>
<img src="/2021/10/27/flyway%E7%AE%80%E4%BB%8B/database-version.png" class="" title="数据库版本记录">

<h2 id="flyway实践"><a href="#flyway实践" class="headerlink" title="flyway实践"></a>flyway实践</h2><h3 id="添加引用"><a href="#添加引用" class="headerlink" title="添加引用"></a>添加引用</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="comment">&lt;!-- 注意,这是springboot环境中,已经有版本了,所以无需添加,其余环境需要自己看情况 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flywaydb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flyway-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p>springboot为例</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.flyway.enabled</span>=<span class="string">true # 开启flyway,默认true</span></span><br><span class="line"><span class="attr">spring.flyway.baseline-on-migrate</span>=<span class="string">true #当迁移时发现目标schema非空，而且带有没有后设资料的表时，是否自动执行基准迁移，预设false.</span></span><br><span class="line"><span class="attr">spring.flyway.locations</span>=<span class="string">classpath:db/migration # sql文件地址,默认就是 classpath:db/migration </span></span><br><span class="line"><span class="attr">spring.flyway.table</span>=<span class="string">dataease_version # 记录数据库记录的表的名称</span></span><br><span class="line"><span class="attr">spring.flyway.baseline-version</span>=<span class="string">0 # 开始执行基准迁移时对现有的schema的版本打标签，默认值为1</span></span><br><span class="line"><span class="attr">spring.flyway.encoding</span>=<span class="string">UTF-8 # 编码,默认就是UTF-8</span></span><br><span class="line"><span class="attr">spring.flyway.validate-on-migrate</span>=<span class="string">false # 迁移是否校验,默认为true</span></span><br></pre></td></tr></table></figure>

<h3 id="添加sql"><a href="#添加sql" class="headerlink" title="添加sql"></a>添加sql</h3><p>依次执行</p>
<img src="/2021/10/27/flyway%E7%AE%80%E4%BB%8B/dbmigration.png" class="" title="sql文件">

<h2 id="进阶知识点"><a href="#进阶知识点" class="headerlink" title="进阶知识点"></a>进阶知识点</h2><h3 id="版本号规范"><a href="#版本号规范" class="headerlink" title="版本号规范"></a>版本号规范</h3><p>Flyway 是如何比较两个 SQL 文件的先后顺序呢？它采用 采用左对齐原则, 缺位用 0 代替 。举几个例子：</p>
<p>1.0.1.1 比 1.0.1 版本高。<br>1.0.10 比 1.0.9.4 版本高。<br>1.0.10 和 1.0.010 版本号一样高, 每个版本号部分的前导 0 会被忽略。  </p>
<p>Flyway 将 SQL 文件分为 <strong>Versioned</strong> 、<strong>Repeatable</strong> 和 <strong>Undo</strong> 三种：</p>
<ol>
<li>Versioned 用于版本升级, 每个版本有唯一的版本号并只能执行一次.</li>
<li>Repeatable 可重复执行, 当 Flyway检测到 Repeatable 类型的 SQL 脚本的 checksum 有变动,<br>Flyway 就会重新应用该脚本. 它并不用于版本更新, 这类的 migration 总是在 Versioned 执行之后才被执行。</li>
<li>Undo 用于撤销具有相同版本的版本化迁移带来的影响。但是该回滚过于粗暴，过于机械化，一般不推荐使用。一般建议使用 Versioned 模式来解决。</li>
</ol>
<img src="/2021/10/27/flyway%E7%AE%80%E4%BB%8B/concepts_migrations.png" class="" title="命名规则">

<ol>
<li>Prefix 可配置，前缀标识，默认值 V 表示 Versioned, R 表示 Repeatable, U 表示 Undo</li>
<li>Version 标识版本号, 由一个或多个数字构成, 数字之间的分隔符可用点 . 或下划线 _</li>
<li>Separator 可配置, 用于分隔版本标识与描述信息, 默认为两个下划线 __</li>
<li>Description 描述信息, 文字之间可以用下划线 _ 或空格 分隔</li>
<li>Suffix 可配置, 后续标识, 默认为 .sql</li>
</ol>
<h3 id="另一种sql文件夹风格"><a href="#另一种sql文件夹风格" class="headerlink" title="另一种sql文件夹风格"></a>另一种sql文件夹风格</h3><p>可以使用文件夹来区分,但是还是依照版本号规则来执行</p>
<img src="/2021/10/27/flyway%E7%AE%80%E4%BB%8B/sql_directory.png" class="" title="多文件夹">


<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="语义化sql文件名字"><a href="#语义化sql文件名字" class="headerlink" title="语义化sql文件名字"></a>语义化sql文件名字</h3><p>前面给的例子中,都是用的v1,v2,v3这样的版本号,其实是非常不友好的,因为这样的话,我不知道我的语义化版本和我的sql脚本到底怎么对应,所以,这样是非常不好的,好的方式应该是<br>使用语义化版本来命名这些sql文件,这样约定下来,就非常清晰</p>
<img src="/2021/10/27/flyway%E7%AE%80%E4%BB%8B/semver_sqlfile.png" class="" title="语义化版本sql文件命名">

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">flyway.baseline-description对执行迁移时基准版本的描述.</span></span><br><span class="line"><span class="attr">flyway.baseline-on-migrate当迁移时发现目标schema非空，而且带有没有元数据的表时，是否自动执行基准迁移，默认false.</span></span><br><span class="line"><span class="attr">flyway.baseline-version开始执行基准迁移时对现有的schema的版本打标签，默认值为1.</span></span><br><span class="line"><span class="attr">flyway.check-location检查迁移脚本的位置是否存在，默认false.</span></span><br><span class="line"><span class="attr">flyway.clean-on-validation-error当发现校验错误时是否自动调用clean，默认false.</span></span><br><span class="line"><span class="attr">flyway.enabled是否开启flywary，默认true.</span></span><br><span class="line"><span class="attr">flyway.encoding设置迁移时的编码，默认UTF-8.</span></span><br><span class="line"><span class="attr">flyway.ignore-failed-future-migration当读取元数据表时是否忽略错误的迁移，默认false.</span></span><br><span class="line"><span class="attr">flyway.init-sqls当初始化好连接时要执行的SQL.</span></span><br><span class="line"><span class="attr">flyway.locations迁移脚本的位置，默认db/migration.</span></span><br><span class="line"><span class="attr">flyway.out-of-order是否允许无序的迁移，默认false.</span></span><br><span class="line"><span class="attr">flyway.password目标数据库的密码.</span></span><br><span class="line"><span class="attr">flyway.placeholder-prefix设置每个placeholder的前缀，默认$&#123;.</span></span><br><span class="line"><span class="attr">flyway.placeholder-replacementplaceholders是否要被替换，默认true.</span></span><br><span class="line"><span class="attr">flyway.placeholder-suffix设置每个placeholder的后缀，默认&#125;.</span></span><br><span class="line"><span class="attr">flyway.placeholders.[placeholder</span> <span class="string">name]设置placeholder的value</span></span><br><span class="line"><span class="attr">flyway.schemas设定需要flywary迁移的schema，大小写敏感，默认为连接默认的schema.</span></span><br><span class="line"><span class="attr">flyway.sql-migration-prefix迁移文件的前缀，默认为V.</span></span><br><span class="line"><span class="attr">flyway.sql-migration-separator迁移脚本的文件名分隔符，默认__</span></span><br><span class="line"><span class="attr">flyway.sql-migration-suffix迁移脚本的后缀，默认为.sql</span></span><br><span class="line"><span class="attr">flyway.tableflyway使用的元数据表名，默认为schema_version</span></span><br><span class="line"><span class="attr">flyway.target迁移时使用的目标版本，默认为latest</span> <span class="string">version</span></span><br><span class="line"><span class="attr">flyway.url迁移时使用的JDBC</span> <span class="string">URL，如果没有指定的话，将使用配置的主数据源</span></span><br><span class="line"><span class="attr">flyway.user迁移数据库的用户名</span></span><br><span class="line"><span class="attr">flyway.validate-on-migrate迁移时是否校验，默认为true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>数据库版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>javaagent简介</title>
    <url>/2022/05/30/javaagent%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="javaagent的作用"><a href="#javaagent的作用" class="headerlink" title="javaagent的作用"></a>javaagent的作用</h1><p>javaAgent属于java比较高级的用法,平常java开发中几乎是接触不到的,比如<code>skywalking</code>用到了javaAgent的启动前的<code>premain</code>,因为可以修改加载的类,被用来做jvm级别的AOP,然后jvm诊断工具,<code>Arthas</code>用到了javaAgent的<code>agentmain</code>,启动后,也可以修改jvm的类,然后做jvm级别的AOP,然后做监控,当然<code>Arthas</code>还有很多其它的功能,不过大部分功能都和<code>agentmain</code>相关,需要修改现成的类</p>
<h2 id="javaagent是什么"><a href="#javaagent是什么" class="headerlink" title="javaagent是什么"></a>javaagent是什么</h2><p>javaagent是java5开始提供的一种机制,java6还增强了<br>java启动的时候,增加了javaagent参数,参数 javaagent 可以用于指定一个 jar 包,并且对该 java 包有2个要求：</p>
<ol>
<li>这个 jar 包的 MANIFEST.MF 文件必须指定 Premain-Class 项</li>
<li>Premain-Class 指定的那个类必须实现 premain() 方法.</li>
</ol>
<p>premain 方法,从字面上理解,就是运行在 main 函数之前的的类.当Java虚拟机启动时,在执行main函数之前,JVM会先运行-javaagent所指定jar包内 Premain-Class这个类的premain方法.<br>输入java参数,还可以看到其余的和agent相关的参数:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-agentlib:&lt;libname&gt;[=&lt;options&gt;]</span><br><span class="line">              load native agent library &lt;libname&gt;, e.g. -agentlib:hprof</span><br><span class="line">              see also, -agentlib:jdwp=help and -agentlib:hprof=help</span><br><span class="line">-agentpath:&lt;pathname&gt;[=&lt;options&gt;]</span><br><span class="line">              load native agent library by full pathname</span><br><span class="line">-javaagent:&lt;jarpath&gt;[=&lt;options&gt;]</span><br><span class="line">              load Java programming language agent, see java.lang.instrument</span><br></pre></td></tr></table></figure>

<img src="/2022/05/30/javaagent%E7%AE%80%E4%BB%8B/two-important-class.png" class="" title="Instrumentation所在的模块">

<h2 id="javaagent的用途"><a href="#javaagent的用途" class="headerlink" title="javaagent的用途"></a>javaagent的用途</h2><ol>
<li><code>permain</code>可以替换java类,但是一般,我们不可能把a类替换成b类,这样做基本没有任何意义,我们一般做的,就是JVM级别的AOP,比如<code>skywalking</code>就是这样做的</li>
<li><code>agentmain</code>可以对运行时的jvm里面的类,做修改,不过一般也是做jvm级别的aop,搞监控使用</li>
<li><code>agentmain</code>因为可以修改java类,但是限制比较多,一般你认为只能修改方法体内的内容才行,别的不可以,大致就是这样</li>
<li><code>agentmain</code>一般都是jvm监控工具才使用的api,原来不能用java写,后来出现的<code>javaagent</code>机制就是使可以用java写,平常我们编程中基本用不到,了解即可</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaagent</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射到底有多慢</title>
    <url>/2025/03/22/java%E5%8F%8D%E5%B0%84%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%85%A2/</url>
    <content><![CDATA[<h1 id="java反射到底有多慢"><a href="#java反射到底有多慢" class="headerlink" title="java反射到底有多慢"></a>java反射到底有多慢</h1><h2 id="java反射慢吗"><a href="#java反射慢吗" class="headerlink" title="java反射慢吗"></a>java反射慢吗</h2><p>java反射慢,我想这个现象大家都知道,但是为什么慢,到底慢多少,这个好像还真没有人深究过,今天就来探索一下</p>
<h2 id="先写benchmark"><a href="#先写benchmark" class="headerlink" title="先写benchmark"></a>先写benchmark</h2><p>这是git仓库的地址<br><a href="https://gitee.com/david0624/java-reflect-benchmark">java-reflect-benchmark</a></p>
<h2 id="影响反射快慢的方式有哪些"><a href="#影响反射快慢的方式有哪些" class="headerlink" title="影响反射快慢的方式有哪些"></a>影响反射快慢的方式有哪些</h2><ol>
<li>调用方式,使用Method还是MethodHandle</li>
<li>是否使用多态,即是使用接口调用,还是使用类调用</li>
<li>形参的数量,因为动态需要做检查,所以数量多了,就表现出来了</li>
<li>形参是对象还是primitive类型,因为涉及到装箱,拆箱</li>
<li>jdk版本的差异,比如8 11 17 21等等</li>
</ol>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>我在自己机器上跑的,只是简要测试,并不太严谨,严谨的测试,应该专门找一个没有任何负载的物理机器,专门跑这个测试,才能排除一切的干扰,<br>不过最后的结果也很有参考价值,先上jdk8的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Benchmark                                                Mode  Cnt  Score   Error  Units</span><br><span class="line">ReflectTest.genericDirectCall                            avgt    3  0.239 ± 0.023  ns/op</span><br><span class="line">ReflectTest.genericMethodHandleCall                      avgt    3  1.815 ± 0.236  ns/op</span><br><span class="line">ReflectTest.genericReflectionCall                        avgt    3  2.139 ± 0.754  ns/op</span><br><span class="line">ReflectTest.noParameterDirectCall                        avgt    3  0.237 ± 0.015  ns/op</span><br><span class="line">ReflectTest.noParameterMethodHandleCall                  avgt    3  1.823 ± 0.198  ns/op</span><br><span class="line">ReflectTest.noParameterTestReflectionCall                avgt    3  1.672 ± 0.452  ns/op</span><br><span class="line">ReflectTest.oneObjectParameterDirectCall                 avgt    3  0.241 ± 0.022  ns/op</span><br><span class="line">ReflectTest.oneObjectParameterMethodHandleCall           avgt    3  1.818 ± 0.304  ns/op</span><br><span class="line">ReflectTest.oneObjectParameterReflectionCall             avgt    3  2.120 ± 1.026  ns/op</span><br><span class="line">ReflectTest.oneParameterInterfaceMethodDirectCall        avgt    3  0.329 ± 0.052  ns/op</span><br><span class="line">ReflectTest.oneParameterInterfaceMethodMethodHandleCall  avgt    3  1.839 ± 0.328  ns/op</span><br><span class="line">ReflectTest.oneParameterInterfaceMethodReflectionCall    avgt    3  2.140 ± 0.625  ns/op</span><br><span class="line">ReflectTest.onePrimateParameterDirectCall                avgt    3  0.246 ± 0.061  ns/op</span><br><span class="line">ReflectTest.onePrimateParameterMethodHandleCall          avgt    3  1.786 ± 0.190  ns/op</span><br><span class="line">ReflectTest.onePrimateParameterReflectionCall            avgt    3  2.275 ± 0.519  ns/op</span><br><span class="line">ReflectTest.override1DirectCall1                         avgt    3  0.241 ± 0.028  ns/op</span><br><span class="line">ReflectTest.override1DirectCall2                         avgt    3  0.249 ± 0.043  ns/op</span><br><span class="line">ReflectTest.override1DirectCall3                         avgt    3  0.250 ± 0.020  ns/op</span><br><span class="line">ReflectTest.override1MethodHandleCall1                   avgt    3  1.848 ± 0.648  ns/op</span><br><span class="line">ReflectTest.override1MethodHandleCall2                   avgt    3  1.795 ± 0.229  ns/op</span><br><span class="line">ReflectTest.override1MethodHandleCall3                   avgt    3  1.810 ± 0.086  ns/op</span><br><span class="line">ReflectTest.override1ReflectionCall1                     avgt    3  2.049 ± 0.461  ns/op</span><br><span class="line">ReflectTest.override1ReflectionCall2                     avgt    3  2.087 ± 0.063  ns/op</span><br><span class="line">ReflectTest.override1ReflectionCall3                     avgt    3  2.549 ± 0.369  ns/op</span><br><span class="line">ReflectTest.threeObjectParameterDirectCall               avgt    3  0.245 ± 0.023  ns/op</span><br><span class="line">ReflectTest.threeObjectParameterMethodHandleCall         avgt    3  1.822 ± 0.097  ns/op</span><br><span class="line">ReflectTest.threeObjectParameterReflectionCall           avgt    3  2.553 ± 0.175  ns/op</span><br><span class="line">ReflectTest.threePrimateParameterDirectCall              avgt    3  0.246 ± 0.120  ns/op</span><br><span class="line">ReflectTest.threePrimateParameterMethodHandleCall        avgt    3  1.820 ± 0.363  ns/op</span><br><span class="line">ReflectTest.threePrimateParameterReflectionCall          avgt    3  4.038 ± 0.640  ns/op</span><br><span class="line">ReflectTest.twoObjectParameterDirectCall                 avgt    3  0.253 ± 0.019  ns/op</span><br><span class="line">ReflectTest.twoObjectParameterMethodHandleCall           avgt    3  1.797 ± 0.232  ns/op</span><br><span class="line">ReflectTest.twoObjectParameterReflectionCall             avgt    3  2.175 ± 0.405  ns/op</span><br><span class="line">ReflectTest.twoPrimateParameterDirectCall                avgt    3  0.249 ± 0.031  ns/op</span><br><span class="line">ReflectTest.twoPrimateParameterMethodHandleCall          avgt    3  1.799 ± 0.207  ns/op</span><br><span class="line">ReflectTest.twoPrimateParameterReflectionCall            avgt    3  2.980 ± 0.725  ns/op</span><br></pre></td></tr></table></figure>

<p>这是jdk21的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Benchmark                                                Mode  Cnt  Score   Error  Units</span><br><span class="line">ReflectTest.genericDirectCall                            avgt    3  0.259 ± 0.111  ns/op</span><br><span class="line">ReflectTest.genericMethodHandleCall                      avgt    3  2.092 ± 0.183  ns/op</span><br><span class="line">ReflectTest.genericReflectionCall                        avgt    3  3.778 ± 0.286  ns/op</span><br><span class="line">ReflectTest.noParameterDirectCall                        avgt    3  0.264 ± 0.095  ns/op</span><br><span class="line">ReflectTest.noParameterMethodHandleCall                  avgt    3  1.936 ± 0.251  ns/op</span><br><span class="line">ReflectTest.noParameterTestReflectionCall                avgt    3  3.522 ± 0.401  ns/op</span><br><span class="line">ReflectTest.oneObjectParameterDirectCall                 avgt    3  0.258 ± 0.134  ns/op</span><br><span class="line">ReflectTest.oneObjectParameterMethodHandleCall           avgt    3  1.997 ± 0.286  ns/op</span><br><span class="line">ReflectTest.oneObjectParameterReflectionCall             avgt    3  3.738 ± 0.169  ns/op</span><br><span class="line">ReflectTest.oneParameterInterfaceMethodDirectCall        avgt    3  0.400 ± 0.029  ns/op</span><br><span class="line">ReflectTest.oneParameterInterfaceMethodMethodHandleCall  avgt    3  2.037 ± 0.350  ns/op</span><br><span class="line">ReflectTest.oneParameterInterfaceMethodReflectionCall    avgt    3  4.038 ± 0.027  ns/op</span><br><span class="line">ReflectTest.onePrimateParameterDirectCall                avgt    3  0.256 ± 0.020  ns/op</span><br><span class="line">ReflectTest.onePrimateParameterMethodHandleCall          avgt    3  1.955 ± 0.053  ns/op</span><br><span class="line">ReflectTest.onePrimateParameterReflectionCall            avgt    3  4.077 ± 0.326  ns/op</span><br><span class="line">ReflectTest.override1DirectCall1                         avgt    3  0.265 ± 0.139  ns/op</span><br><span class="line">ReflectTest.override1DirectCall2                         avgt    3  0.256 ± 0.028  ns/op</span><br><span class="line">ReflectTest.override1DirectCall3                         avgt    3  0.256 ± 0.023  ns/op</span><br><span class="line">ReflectTest.override1MethodHandleCall1                   avgt    3  1.993 ± 0.303  ns/op</span><br><span class="line">ReflectTest.override1MethodHandleCall2                   avgt    3  2.086 ± 0.172  ns/op</span><br><span class="line">ReflectTest.override1MethodHandleCall3                   avgt    3  2.085 ± 0.174  ns/op</span><br><span class="line">ReflectTest.override1ReflectionCall1                     avgt    3  3.706 ± 0.149  ns/op</span><br><span class="line">ReflectTest.override1ReflectionCall2                     avgt    3  3.830 ± 0.201  ns/op</span><br><span class="line">ReflectTest.override1ReflectionCall3                     avgt    3  4.042 ± 0.418  ns/op</span><br><span class="line">ReflectTest.threeObjectParameterDirectCall               avgt    3  0.272 ± 0.025  ns/op</span><br><span class="line">ReflectTest.threeObjectParameterMethodHandleCall         avgt    3  2.095 ± 0.212  ns/op</span><br><span class="line">ReflectTest.threeObjectParameterReflectionCall           avgt    3  4.038 ± 0.442  ns/op</span><br><span class="line">ReflectTest.threePrimateParameterDirectCall              avgt    3  0.262 ± 0.067  ns/op</span><br><span class="line">ReflectTest.threePrimateParameterMethodHandleCall        avgt    3  2.076 ± 0.121  ns/op</span><br><span class="line">ReflectTest.threePrimateParameterReflectionCall          avgt    3  4.546 ± 2.780  ns/op</span><br><span class="line">ReflectTest.twoObjectParameterDirectCall                 avgt    3  0.257 ± 0.016  ns/op</span><br><span class="line">ReflectTest.twoObjectParameterMethodHandleCall           avgt    3  2.104 ± 0.344  ns/op</span><br><span class="line">ReflectTest.twoObjectParameterReflectionCall             avgt    3  3.860 ± 0.397  ns/op</span><br><span class="line">ReflectTest.twoPrimateParameterDirectCall                avgt    3  0.262 ± 0.081  ns/op</span><br><span class="line">ReflectTest.twoPrimateParameterMethodHandleCall          avgt    3  1.990 ± 0.337  ns/op</span><br><span class="line">ReflectTest.twoPrimateParameterReflectionCall            avgt    3  4.267 ± 0.496  ns/op</span><br></pre></td></tr></table></figure>

<p>具体的结果,可以在git仓库的doc目录找到,而且这个项目开箱即用,如果想测试的话,自己本机测试跑跑也可以的</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li>反射从微观层面来说,增加了至少7.69倍的调用时间(最简单的无形参调用),如果是原始类型的多形参调用,以3个原始类型为例,竟然可以是16.14倍,从微观层面讲,的确反射很慢</li>
<li>反射,装箱,拆箱的话,效率更低,的确原始类型的拆箱装箱大量调用,对性能有一定的损耗</li>
<li>MethodHandle相比Method的确存在优化,在jdk21的时候,一些反射耗时较长的时候,竟然能达到它的一半</li>
<li>反射从微观层面讲,一个方法的调用增加了7.69~16.14倍的调用时间,但是实际情况下,方法如果本身的执行时间比较长,这个时间其实是可以忽略的,因为本身方法的调用时间就不长,<br>但是如果是大量耗时十分短的方法,长时间大量调用,这个就比较可观了</li>
<li>现在编程的环境,开发效率大于执行效率,反射其实是个非常强大的特性,经常被框架大量使用</li>
<li>spring就重度使用反射,几乎spring的所有功能都依赖反射,但是spring的效率低下,反射只是其中一个原因</li>
</ol>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>总体来说,java反射的慢是可以接受的,但是,现在去反射也有这样的框架,比如micronaut,就通过annotationProcessor生成静态的类,然后避免了反射,启动速度大幅降低,<br>如果能消除反射,程序的性能也是可以得到一定程度的提高的</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java热加载</tag>
      </tags>
  </entry>
  <entry>
    <title>java中classloader的作用</title>
    <url>/2022/05/29/java%E4%B8%ADclassloader%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="classLoader的作用"><a href="#classLoader的作用" class="headerlink" title="classLoader的作用"></a>classLoader的作用</h1><p>java的类加载机制,从9开始,已经做出了更改,本文基于java9,所以会和其它的资料不太一样</p>
<ol>
<li>jvm使用classLoader加载<code>.class</code>文件变成<code>class</code>对象</li>
<li>每个<code>class</code>对象都有自己的<code>ClassLoader</code>对象,谁加载的它,它的<code>ClassLoader</code>就是谁,这个可能是native的<code>defineClass</code>逻辑中的方法决定的</li>
<li>jvm使用<code>ClassLoader</code>+类名字来确定一个类,所以,不同<code>ClassLoader</code>的类无论是否一样,都不会强转成功的</li>
<li>一个<code>ClassLoader</code>只能加载一个类一次,再次加载相同名字的类,native方法会报错(只要你用了<code>defineClass</code>方法,但是你也必须用)</li>
</ol>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p><code>ClassLoader</code>按照实际的需要加载需要的类,一个类如果被关联,那么它会被<code>ClassLoader</code>从给定的方式找到,如果找不到,<br>就是<code>ClassNotFoundException</code>,对于java9来说,有一种很方便的方法可以看到到底加载了多少类</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java &lt;app_name&gt; -Xlog:class+load=info:classloaded.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[0.001s][info][class,load] opened: /home/ss/.jdks/azul-15.0.6/lib/modules</span><br><span class="line">[0.005s][info][class,load] java.lang.Object source: shared objects file</span><br><span class="line">[0.005s][info][class,load] java.io.Serializable source: shared objects file</span><br><span class="line">[0.005s][info][class,load] java.lang.Comparable source: shared objects file</span><br><span class="line">[0.005s][info][class,load] java.lang.CharSequence source: shared objects file</span><br></pre></td></tr></table></figure>
<p>随便一个helloWord,基本上都需要加载大约900多个类,包含内部类,而不会把所有的类都加载上</p>
<h2 id="分层加载"><a href="#分层加载" class="headerlink" title="分层加载"></a>分层加载</h2><p>jvm的规范已经定了,class文件也已经编译好了,加载更多的时候,只是从哪里找到class这个问题,对于java9</p>
<ol>
<li><code>bootstrap</code>类加载器<code>BootClassLoader</code>,现在变成了java写的,但是为了兼容性,<code>String.class</code>的<code>ClassLoader</code>还是null</li>
<li><code>platform</code>类加载器<code>PlatformClassLoader</code>,<code>PlatformClassLoader</code>的parent现在不是null了,而是<code>BootClassLoader</code></li>
<li><code>app</code>类加载器<code>AppClassLoader</code>,父加载器是<code>platform</code></li>
</ol>
<p>同样的继承体系,但是加载的时候,自己写的模块肯定是<code>app</code>加载的,但是jdk的代码,可能是<code>bootstrap</code>,<code>platform</code>,<code>app</code>加载的,当然,<code>String</code>,<code>System</code>这些核心类还是<code>bootstrap</code>加载的,具体的模块可以用以下代码测试出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;String-&gt;&quot;</span> + String.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;String-&gt;&quot;</span> + System.class.getClassLoader());</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">ModuleLayer</span> <span class="variable">layer</span> <span class="operator">=</span> ModuleLayer.boot();</span><br><span class="line">        layer.modules().forEach(<span class="keyword">module</span> -&gt; &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">module</span>.getClassLoader();</span><br><span class="line">            <span class="type">String</span> <span class="variable">classLoaderName</span> <span class="operator">=</span> isNull(classLoader) ? <span class="string">&quot;bootstrap&quot;</span> : classLoader.getName();</span><br><span class="line">            System.out.println(classLoaderName + <span class="string">&quot;: &quot;</span> + <span class="keyword">module</span>.getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">String-&gt;null</span><br><span class="line">String-&gt;null</span><br><span class="line"></span><br><span class="line">bootstrap: java.base</span><br><span class="line">bootstrap: java.datatransfer</span><br><span class="line">platform: jdk.localedata</span><br><span class="line">bootstrap: java.instrument</span><br><span class="line">bootstrap: java.xml</span><br><span class="line">app: jdk.jlink</span><br><span class="line">bootstrap: java.logging</span><br><span class="line">app: jdk.javadoc</span><br><span class="line">bootstrap: java.rmi</span><br><span class="line">bootstrap: jdk.naming.rmi</span><br><span class="line">app: jdk.jdeps</span><br><span class="line">app: jdk.jartool</span><br><span class="line">bootstrap: java.prefs</span><br><span class="line">platform: java.smartcardio</span><br><span class="line">bootstrap: java.management.rmi</span><br><span class="line">app: j11hello</span><br><span class="line">platform: jdk.zipfs</span><br><span class="line">platform: java.xml.crypto</span><br><span class="line">bootstrap: java.security.sasl</span><br><span class="line">bootstrap: java.management</span><br><span class="line">platform: java.security.jgss</span><br><span class="line">bootstrap: jdk.jfr</span><br><span class="line">app: jdk.internal.opt</span><br><span class="line">platform: jdk.crypto.ec</span><br><span class="line">bootstrap: java.naming</span><br><span class="line">app: jdk.unsupported.desktop</span><br><span class="line">bootstrap: java.desktop</span><br><span class="line">platform: jdk.security.auth</span><br><span class="line">platform: jdk.crypto.cryptoki</span><br><span class="line">platform: jdk.charsets</span><br><span class="line">bootstrap: jdk.management</span><br><span class="line">bootstrap: jdk.management.jfr</span><br><span class="line">platform: jdk.security.jgss</span><br><span class="line">platform: jdk.naming.dns</span><br><span class="line">app: jdk.compiler</span><br><span class="line">platform: java.compiler</span><br></pre></td></tr></table></figure>

<p>debug模式下,可以通过<code>nameToModule</code>看到</p>
<img src="/2022/05/29/java%E4%B8%ADclassloader%E7%9A%84%E4%BD%9C%E7%94%A8/classLoader%E7%BB%A7%E6%89%BF.png" class="" title="classLoader继承和nameToModule">

<h2 id="优先父类加载-双亲委派"><a href="#优先父类加载-双亲委派" class="headerlink" title="优先父类加载(双亲委派)"></a>优先父类加载(双亲委派)</h2><p>类加载的时候,优先会让父类加载,然后一级级往上找,正好两层父类,所以,也叫<code>双亲委派</code>,经常面试中问到,其实就是个优先级问题,这样做有两个需要</p>
<ol>
<li>确保不重复加载类,确保类的唯一性,</li>
<li>也顺带解决了一部分安全性,比如自己写个string,肯定就不能加载成功了,当然,jdk肯定也有其它的安全机制来保证的</li>
</ol>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>jvm的类规范已经定好了,你的<code>classpath</code>也已经写好了,那么还为什么需要自定义类加载器呢,主要是一些框架,或者是中间件才需要,比如tomcat,有自己的lib,还有<code>flink</code>也有别的lib需要加载,这些时候,就需要从别的地方来加载类,还有些需求,比如你的类是加密的,这个时候,肯定也是需要自定义类加载器的</p>
<p><code>ClassLoader</code>中,有三个方法我们需要注意<code>loadClass</code>,<code>findClass</code>,<code>defineClass</code>,</p>
<ol>
<li><code>loadClass</code>定义了父类优先加载的机制,如果你需要打破这个机制,如<code>flink</code>那么你就需要重写这个方法,可以变成子类优先</li>
<li><code>findClass</code>,如果你只是需要加密解密,那么你的逻辑在这里做,就很合适了,找到对应的文件,读取成字节数组,然后解密以后,调用<code>defineClass</code>返回即可</li>
<li><code>defineClass</code>的实现,主要逻辑是本地方法,把字节数组,变成class对象,你基本上无需关心,只需要知道它的作用使用即可</li>
</ol>
<h2 id="Class-forName对比ClassLoader-loadClass"><a href="#Class-forName对比ClassLoader-loadClass" class="headerlink" title="Class.forName对比ClassLoader.loadClass"></a>Class.forName对比ClassLoader.loadClass</h2><p>两个方法基本作用相同,但是<code>forName</code>是的主要逻辑在本地方法,可以加载基本类型的数组类型,虽然<code>loadClass</code>虽然也会让父加载器去找,但是找不到,注意这种区别,一般应该优先使用<code>forName</code>方法去加载类</p>
<h2 id="多版本的类共存"><a href="#多版本的类共存" class="headerlink" title="多版本的类共存"></a>多版本的类共存</h2><p>比如框架本身需要一个类,但是下面的代码又可能使用一个不知道什么版本的类,这个时候,既不能指定下面的代码使用什么版本,同时框架自身也要用,shade插件在这个时候,就起到作用了,具体的工作原理就是,把类名全部改了,然后把框架本身引用到的地方也全部都改了,这样,通过改类名,相对比较简单的就做到了多个版本的类共存,对应的maven插件叫<code>maven-shade-plugin</code>,比如<code>flink</code>,<code>skywalking</code>这类中间件都会用到这样的技术</p>
<h2 id="当前线程的类加载器"><a href="#当前线程的类加载器" class="headerlink" title="当前线程的类加载器"></a>当前线程的类加载器</h2><p>如果不同的线程,需要不同的<code>ClassLoader</code>来加载多个版本的<code>Class</code>,或者加载<code>Class</code>的机制不一样,那么,可以使用<code>java.lang.Thread#getContextClassLoader</code>,不同的线程使用不同的<code>ClassLoader</code>,起到很好的隔离作用</p>
<p>一般的场景用不到,一般用在框架或者中间件的需求中,比如<code>flink</code>,不同的地方使用的<code>ClassLoader</code>不一样,通过<code>setContextClassLoader</code>来隔离,<code>getContextClassLoader</code>来使用</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实大部分情况下,你不开发框架,不开发中间件,基本上是用不到<code>ClassLoader</code>的,但是为什么面试中,还是经常会问呢?中国人讲究学以致用,但是如果你用不到这样的场景呢?你还用学嘛?所以了解一下大致的作用就好了</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>classLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>java热加载机制的实现方式简介</title>
    <url>/2022/05/29/java%E7%83%AD%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="java热部署机制的实现方式简介"><a href="#java热部署机制的实现方式简介" class="headerlink" title="java热部署机制的实现方式简介"></a>java热部署机制的实现方式简介</h1><h2 id="热部署和热加载定义"><a href="#热部署和热加载定义" class="headerlink" title="热部署和热加载定义"></a>热部署和热加载定义</h2><p>可以看到,热部署是包含热加载的,不过,这些概念并不太重要</p>
<img src="/2022/05/29/java%E7%83%AD%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%AE%80%E4%BB%8B/airplane.jpeg" class="" title="热部署相当于给飞行中的飞机更换引擎">

<h3 id="热部署-hot-deploy"><a href="#热部署-hot-deploy" class="headerlink" title="热部署 hot deploy"></a>热部署 hot deploy</h3><p>热部署针对的是容器或者是整个应用，部署了新的资源或者修改了一些代码，需要在不停机的情况下的重新加载整个应用。</p>
<h3 id="热加载-hotswap"><a href="#热加载-hotswap" class="headerlink" title="热加载 hotswap"></a>热加载 hotswap</h3><p>热加载针对的是单个字节码文件，指的是重新编译后，不需要停机，应用程序就可以加载使用新的class文件</p>
<h2 id="目前存在的方案"><a href="#目前存在的方案" class="headerlink" title="目前存在的方案"></a>目前存在的方案</h2><h3 id="java-hotswap"><a href="#java-hotswap" class="headerlink" title="java hotswap"></a>java hotswap</h3><p>Java Platform Debugger Architecture是java IDE 调试的基础,<br>修改jvm启动参数即可打开,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n</span><br></pre></td></tr></table></figure>
<p>技术原理也是java instrument api,<br>确定：仅能修改方法体，不能增加修改方法、field</p>
<h2 id="另一种可行的思路"><a href="#另一种可行的思路" class="headerlink" title="另一种可行的思路"></a>另一种可行的思路</h2><p>实现的思路是多种多样的,比如可以定制jvm,但是这里不讨论这些,这里只是讨论其中一种相对简单的实现  </p>
<p>因为jvm中的class是不可变的,而且同一个classloader的同一个名字的class,jvm才会当作一个class,所以,不能直接去改变class,需要变通一下,用自定义的classloader<br>去加载新的class,同时业务上,需要去使用新的class,这样才可以变相的达到目的,</p>
<h2 id="如何生成新的class"><a href="#如何生成新的class" class="headerlink" title="如何生成新的class"></a>如何生成新的class</h2><ol>
<li>自己用字节码生成,相对硬核一些,不太友好,也不方便</li>
<li>用源码生成,相对简单,直接,更友好</li>
</ol>
<h3 id="自己使用字节码生成"><a href="#自己使用字节码生成" class="headerlink" title="自己使用字节码生成"></a>自己使用字节码生成</h3><p>java的库比较丰富,字节码框架还是非常多的,无论是基础的ASM,还是javaAssist,还是byteBuddy,都是各有千秋,适用于不同的场景,可以自行选择</p>
<h3 id="用源码生成"><a href="#用源码生成" class="headerlink" title="用源码生成"></a>用源码生成</h3><ol>
<li>groovy编译java源码</li>
<li>eclipse的ECJ</li>
<li>java的JSR199的JavaCompilerAPI</li>
</ol>
<h4 id="groovy编译java源码"><a href="#groovy编译java源码" class="headerlink" title="groovy编译java源码"></a>groovy编译java源码</h4><p>groovy是个好东西,尤其是当你需要动态特性的时候,没错,groovy本来写的编译器是用来编译groovy源码的,但是需要交叉编译,所以,顺带也会编译java的代码,所以,没错,groovy的compiler也会编译java的代码,没有任何的问题</p>
<h4 id="eclipse的ECJ"><a href="#eclipse的ECJ" class="headerlink" title="eclipse的ECJ"></a>eclipse的ECJ</h4><p>eclipse本来是java的IDE,为了实现增量编译之类的一些特性吧,或者是别的特性,eclipse自己也开发了一套编译器,用来编译java的代码</p>
<h4 id="java的JSR199的JavaCompilerAPI"><a href="#java的JSR199的JavaCompilerAPI" class="headerlink" title="java的JSR199的JavaCompilerAPI"></a>java的JSR199的JavaCompilerAPI</h4><p>这个就是直接的java api,原生的,相当于包裹了一下javac,效率不错</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>groovy和ecj的方式非常简单,java的jsr199相对繁琐,但是原生,跟着jdk版本走,最有效,相对来说,可能性能也最好,兼容性也更好,但是需要JDK,你装一个JRE是不行的</p>
<h2 id="如何加载新的class"><a href="#如何加载新的class" class="headerlink" title="如何加载新的class"></a>如何加载新的class</h2><p>前面提到的思路,已经说明了,java的同名类,类加载其必须是不同的,所以,每次加载,都需要一个新的classLoader,不过不用担心内存泄漏,java的class也是会内存回收的,原来不用的类,你只要切断所有的引用,这个类也是可以回收的</p>
<h2 id="真的那么简单吗"><a href="#真的那么简单吗" class="headerlink" title="真的那么简单吗"></a>真的那么简单吗</h2><p>其实讲到这里,技术的问题其实都已经解决了,但是类加载,不光光是技术上的问题,还有很多业务的问题,比如,类更改以后,如果让新的对象,全部派生自这个类,还有,尤其是对一些复杂的系统,比如spring,里面有相对复杂的初始化机制,问题就没那么简单,所以,<br>一旦类改变以后,你甚至还是触发一系列刷新的动作才可以,这里想表达的是,一旦类重新以后,jvm本质上是一个静态的系统,不是为动态设计的,所以,一旦出现动态以后,业务上差不多对是要做调整和兼容的,所以,使用的时候,想要和业务相结合</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本文,分析了一种热加载的技术,就是直接用别的classloader加载一个新的同名类,然后再使用业务上的方式让这个重新加载的类生效,同时,也顺带的分析了,如何生成一个新的类的几种方式,并做了简单的对比</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java热加载</tag>
      </tags>
  </entry>
  <entry>
    <title>java编码终极指南1</title>
    <url>/2022/08/04/java%E7%BC%96%E7%A0%81%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%971/</url>
    <content><![CDATA[<h1 id="java中的编码"><a href="#java中的编码" class="headerlink" title="java中的编码"></a>java中的编码</h1><img src="/2022/08/04/java%E7%BC%96%E7%A0%81%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%971/encode.png" class="" title="计算机编码">

<p>关于字符编码的方式很多,比如常用的有unicode系列的utf8,utf16,utf32,还有中国的gb2312,GBK,GBK18030等等,这些网上的资料很多,但都不是本集要讲的内容,本集要讲的内容只有三个</p>
<ol>
<li>java的文件编码</li>
<li>java的string的外在编码</li>
<li>java的string的内在编码,jvm用的编码</li>
</ol>
<p><strong>本文所有的讨论,直接基于jdk17,不见兼顾jdk8,所以,不会讨论历史的情况</strong></p>
<h3 id="1-java的文件编码"><a href="#1-java的文件编码" class="headerlink" title="1. java的文件编码"></a>1. java的文件编码</h3><p>很多时候,大家都会说,防止文件乱码,然后统一使用utf-8,这样做没问题,但是为什么呢,这样做是对的,但是这样做的原因一定是对的嘛?</p>
<ol>
<li>java对于文件的编码方式是可以支持别的,不一定是utf-8,这个<code>javac -help</code>可以看到</li>
<li>用utf-8的确是一个很好的选择,即使你们公司都在国内,用gb2312编码也可以,但是如果,你如果使用了自动的ci,在服务器上编码代码,如果服务器是linux的,那么它的<br>默认编码就可以是utf-8,那你代码编译的时候,就需要手动指定编码方式,而且如果你的项目是开源的,放到github上,那么世界各地都可能有committer,如果各个个国家的人,都用自己<br>本国的编码,那项目就没法玩了,这个时候utf-8就是最佳的选择,所以,无论如何,文件编码使用utf-8都是很好的选择,至少现在就是</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://docs.oracle.com/en/java/javase/17/docs/specs/man/javac.html</span> </span><br><span class="line">-encoding encoding</span><br><span class="line">Specifies character encoding used by source files, such as EUC-JP and UTF-8. If the -encoding option is not specified, then the platform default converter is used.</span><br></pre></td></tr></table></figure>

<h3 id="java的string的外在编码"><a href="#java的string的外在编码" class="headerlink" title="java的string的外在编码"></a>java的string的外在编码</h3><p>java的string的外在编码,指的是<code>String.getBytes()</code>方法使用的编码,这个可以看jdk的源码得到答案,一般oracle jdk会有一些私有代码,代码不是全部公开的,如果有些<br>时候看不到部分代码,可以使用开发的jdk,比如azul,这个时候,几乎就可以看到所有的代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes() &#123;</span><br><span class="line">    <span class="comment">//对外输出的代码,使用默认的编码,那什么是默认的编码呢</span></span><br><span class="line">    <span class="keyword">return</span> encode(Charset.defaultCharset(), coder(), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">defaultCharset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultCharset == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Charset.class) &#123;</span><br><span class="line">        <span class="comment">//file.encoding 是默认的编码</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">csn</span> <span class="operator">=</span> GetPropertyAction</span><br><span class="line">                    .privilegedGetProperty(<span class="string">&quot;file.encoding&quot;</span>);</span><br><span class="line">            <span class="type">Charset</span> <span class="variable">cs</span> <span class="operator">=</span> lookup(csn);</span><br><span class="line">            <span class="keyword">if</span> (cs != <span class="literal">null</span>)</span><br><span class="line">                defaultCharset = cs;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果没有制定,就用默认的UTF-8</span></span><br><span class="line">                defaultCharset = sun.nio.cs.UTF_8.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultCharset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java的string的内在编码-jvm用的编码"><a href="#java的string的内在编码-jvm用的编码" class="headerlink" title="java的string的内在编码,jvm用的编码"></a>java的string的内在编码,jvm用的编码</h3><p>先下结论,java内在的编码,是utf-16,但是也不是,是UTF-16LE,因为java string的外在编码你只要看到的时候,其实就已经发生转换了,所以,你不能直接窥探到,这里我们<br>需要使用反射来窥探到,需要增加参数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--add-opens</span><br><span class="line">java.base/java.lang=ALL-UNNAMED</span><br><span class="line">--add-opens</span><br><span class="line">java.base/sun.net.util=ALL-UNNAMED</span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.apricot.character;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUnicodeTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">HexFormat</span> <span class="variable">of</span> <span class="operator">=</span> HexFormat.of();</span><br><span class="line">        String 我爱你 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱你&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = 我爱你.getBytes();</span><br><span class="line">        System.out.println(bytes.length);</span><br><span class="line">        System.out.println(of.formatHex(bytes));</span><br><span class="line">        Class&lt;String&gt; stringClass = String.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">value</span> <span class="operator">=</span> stringClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        value.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">byte</span>[] originByteArr = (<span class="type">byte</span>[]) value.get(我爱你);</span><br><span class="line">        System.out.println(originByteArr.length);</span><br><span class="line">        System.out.println(of.formatHex(originByteArr));</span><br><span class="line">        <span class="type">byte</span>[] bytes1 = 我爱你.getBytes(StandardCharsets.UTF_16);</span><br><span class="line">        System.out.println(bytes1.length);</span><br><span class="line">        System.out.println(of.formatHex(bytes1));</span><br><span class="line">        <span class="type">byte</span>[] bytes2 = 我爱你.getBytes(StandardCharsets.UTF_16BE);</span><br><span class="line">        System.out.println(bytes2.length);</span><br><span class="line">        System.out.println(of.formatHex(bytes2));</span><br><span class="line">        <span class="type">byte</span>[] bytes3 = 我爱你.getBytes(StandardCharsets.UTF_16LE);</span><br><span class="line">        System.out.println(bytes3.length);</span><br><span class="line">        System.out.println(of.formatHex(bytes3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">e68891e788b1e4bda0</span><br><span class="line">6</span><br><span class="line">11623172604f</span><br><span class="line">8</span><br><span class="line">feff621172314f60</span><br><span class="line">6</span><br><span class="line">621172314f60</span><br><span class="line">6</span><br><span class="line">11623172604f</span><br></pre></td></tr></table></figure>
<p>可以看到直接用反射得到的字节,和UTF_16LE得到的字节是一样的,所以,java的确使用的是UTF_16LE</p>
<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><h4 id="java为什么是UTF-16LE"><a href="#java为什么是UTF-16LE" class="headerlink" title="java为什么是UTF_16LE"></a>java为什么是UTF_16LE</h4><p>这里应该和cpu的架构有关,比如x86的都是小端,little-endian,因为java是跨平台的吗,所以要入乡随俗,然后比如我的cpu是intel 9400,所以,自然就是小端的,<strong>当然这<br>个只是查的有关资料,并不是真的这样确定</strong></p>
<h4 id="为什么utf16多了两个字节"><a href="#为什么utf16多了两个字节" class="headerlink" title="为什么utf16多了两个字节"></a>为什么utf16多了两个字节</h4><p>这里可以看到utf16,多了BOM,而且默认是使用大头</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li>java的文件编码可以支持多种,但是最佳实践是采用utf-8</li>
<li>java的string,默认编码也是utf-8,可以指定默认的,也可以转成其它的</li>
<li>jvm的string编码,是utf16le或者utf16be</li>
</ol>
<p>java编码终极指南2里面会详细介绍<code>sun.jnu.encoding</code>和<code>file.encoding</code></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java编码</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk源码阅读推荐</title>
    <url>/2021/10/05/jdk%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="jdk源码阅读推荐"><a href="#jdk源码阅读推荐" class="headerlink" title="jdk源码阅读推荐"></a>jdk源码阅读推荐</h1><p>java语言有两个规范,一个是java语言的规范,一个时jdk的规范,同时还有一大堆工具构成了我们使用的java.jdk的源码非常多,而且获取也是非常的方便,具体有那些源码值得阅读呢</p>
<h3 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a><code>java.lang</code></h3><p>常用的<code>integer</code>,<code>string</code>,<code>System</code>,<code>Thread</code>这些下面的都需要看一下</p>
<h3 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a><code>java.util</code></h3><p><code>List</code>,<code>Array</code>,<code>Map</code>,等一些其它常用的集合都需要看一下,同时<code>java.util.concurrent</code>这些和并发相关的也需要看一下,异步相关的也在这里面</p>
<h3 id="java-nio"><a href="#java-nio" class="headerlink" title="java.nio"></a><code>java.nio</code></h3><p><code>nio</code>也是高并发的必选,所以也需要看一下</p>
<h3 id="java-net"><a href="#java-net" class="headerlink" title="java.net"></a><code>java.net</code></h3><p>网络相关的和<code>nio</code>也有关系,也需要看一下</p>
]]></content>
      <categories>
        <category>建议</category>
      </categories>
      <tags>
        <tag>阅读源码</tag>
      </tags>
  </entry>
  <entry>
    <title>jprofiler简述</title>
    <url>/2021/10/26/jprofiler%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>基于jprofiler12.0.4</strong></p>
<p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题,在用户体验至上的今天,解决好应用的性能问题能带来非常大的收益.Java 作为最流行的编程语言之一,其应用性能诊断一直受到业界广泛关注.可能造成 Java 应用出现性能问题的因素非常多,例如线程控制、磁盘读写、数据库访问、网络I&#x2F;O、垃圾收集等.想要定位这些问题,一款优秀的性能诊断工具必不可少.本文将介绍 Java 性能诊断过程中的常用工具,并重点介绍其中的优秀代表 JProfiler 的基本原理和最佳实践</p>
<h3 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h3><h4 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h4><p>JDK 内置了许多命令行工具,它们可用来获取目标 JVM 不同方面、不同层次的信息.</p>
<ol>
<li>jinfo - 用于实时查看和调整目标 JVM 的各项参数.</li>
<li>jstack - 用于获取目标 Java 进程内的线程堆栈信息,可用来检测死锁、定位死循环等.</li>
<li>jmap - 用于获取目标 Java 进程的内存相关信息,包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等.</li>
<li>jstat - 一款轻量级多功能监控工具,可用于获取目标 Java 进程的类加载、JIT 编译、垃圾收集、内存使用等信息.</li>
<li>jcmd - 相比 jstat 功能更为全面的工具,可用于获取目标 Java 进程的性能统计、JFR、内存使用、垃圾收集、线程堆栈、JVM 运行时间等信息.</li>
</ol>
<p>阿里开源的<code>arthas</code>,是一款综合诊断的工具</p>
<h4 id="图形化工具"><a href="#图形化工具" class="headerlink" title="图形化工具"></a>图形化工具</h4><p><code>eclise</code>的<code>MAT</code>是专门的内存分析工具,主要用于查找内存是否泄露</p>
<p>JVisualvm 是 JDK 内置的可视化性能诊断工具,它通过 JMX、jstatd、Attach API 等方式获取目标 JVM 的分析数据,包括 CPU 使用率、内存使用量、线程堆栈信息等.此外,它还能直观地展示 Java 堆中各对象的数量和大小、各 Java 方法的调用次数和执行时间等.</p>
<h4 id="分布式监控工具"><a href="#分布式监控工具" class="headerlink" title="分布式监控工具"></a>分布式监控工具</h4><p>如<code>skywalking</code>之类的工具,微服务,云原生,监控分布式应用</p>
<h2 id="jprofiler简述"><a href="#jprofiler简述" class="headerlink" title="jprofiler简述"></a>jprofiler简述</h2><p><code>JProfiler</code> 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具</p>
<ol>
<li>方法调用 - 对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法。</li>
<li>内存分配 - 通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄漏问题，优化内存使用。</li>
<li>线程和锁 - JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题。</li>
<li>高级子系统 - 许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，找出执行最慢的 SQL 语句。JProfiler 支持对这些子系统进行集成分析。</li>
</ol>
<img src="/2021/10/26/jprofiler%E7%AE%80%E8%BF%B0/overview.png" class="" title="概要界面">

<h2 id="jprofiler简介"><a href="#jprofiler简介" class="headerlink" title="jprofiler简介"></a>jprofiler简介</h2><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>JProfiler 包含用于采集目标 JVM 分析数据的 JProfiler agent、用于可视化分析数据的 JProfiler UI、提供各种功能的命令行工具，它们之间的关系如下图所示。</p>
<img src="/2021/10/26/jprofiler%E7%AE%80%E8%BF%B0/jpro_arch.svg" class="" title="结构">

<h3 id="JProfiler-agent"><a href="#JProfiler-agent" class="headerlink" title="JProfiler agent"></a>JProfiler agent</h3><p>JProfiler agent 是一个本地库，它可以在 JVM 启动时通过参数-agentpath:<path to native library>进行加载或者在程序运行时通过 JVM Attach 机制进行加载。Agent 被成功加载后，会设置 JVMTI 环境，监听虚拟机产生的事件，如类加载、线程创建等。例如，当它监听到类加载事件后，会给这些类注入用于执行度量操作的字节码。</p>
<p><a href="http://lovestblog.cn/blog/2014/06/18/jvm-attach/">JVM Attach 机制 相关优秀文章</a></p>
<h3 id="JProfiler-UI"><a href="#JProfiler-UI" class="headerlink" title="JProfiler UI"></a>JProfiler UI</h3><p>JProfiler UI 是一个可独立部署的组件，它通过 socket 和 agent 建立连接。这意味着不论目标 JVM 运行在本地还是远端，JProfiler UI 和 agent 间的通信机制都是一样的。</p>
<h3 id="命令行工具-1"><a href="#命令行工具-1" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>JProfiler 提供了一系列命令行工具以实现不同的功能。</p>
<ol>
<li>jpcontroller - 用于控制 agent 的采集行为。它通过 agent 注册的 JProfiler MBean 向 agent 传递命令。</li>
<li>jpenable - 用于将 agent 加载到一个正在运行的 JVM 上。</li>
<li>jpdump - 用于获取正在运行的 JVM 的堆快照。</li>
<li>jpexport &amp; jpcompare - 用于从保存的快照中提取数据并创建 HTML 报告。</li>
</ol>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><ol>
<li>本地连接</li>
<li>远程连接(ssh tunnel&#x2F;socks proxy)所以,也可以调试线上的机器</li>
</ol>
<h2 id="实用功能简介"><a href="#实用功能简介" class="headerlink" title="实用功能简介"></a>实用功能简介</h2><h3 id="方法耗时"><a href="#方法耗时" class="headerlink" title="方法耗时"></a>方法耗时</h3><img src="/2021/10/26/jprofiler%E7%AE%80%E8%BF%B0/cpu.png" class="" title="方法耗时">

<h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><img src="/2021/10/26/jprofiler%E7%AE%80%E8%BF%B0/live-memory.png" class="" title="内存占用">

<h3 id="jdbc分析"><a href="#jdbc分析" class="headerlink" title="jdbc分析"></a><code>jdbc</code>分析</h3><img src="/2021/10/26/jprofiler%E7%AE%80%E8%BF%B0/jdbc.png" class="" title="jdbc分析">
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中tinyint(1)和tinyint(4)到底有什么区别</title>
    <url>/2019/11/30/mysql%E4%B8%ADtinyint-1-%E5%92%8Ctinyint-4-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="mysql中tinyint-1-和tinyint-4-到底有什么区别"><a href="#mysql中tinyint-1-和tinyint-4-到底有什么区别" class="headerlink" title="mysql中tinyint(1)和tinyint(4)到底有什么区别"></a>mysql中tinyint(1)和tinyint(4)到底有什么区别</h1><h2 id="tinyint基础"><a href="#tinyint基础" class="headerlink" title="tinyint基础"></a>tinyint基础</h2><p>tinyint存储使用了1个字节,就是8位,只能存储2^8即256个数字.在mysql实现中,有符号是-128-127,无符号是0-255,tinyint后面的括号带的数字,以后暂称之为M,<strong>那么1和4到底有什么区别呢?</strong><br>接下来我们就探讨一下M的作用</p>
<h2 id="先下结论"><a href="#先下结论" class="headerlink" title="先下结论"></a>先下结论</h2><ol>
<li>存储上没有任何区别,都是1个字节,8位</li>
<li>唯一的区别就是字段如何设置了zerofill零填充的时候,控制台返回的时候,会根据数字的长度自动填充成对应的位数,现在基本都是可视化操作了,这个特性,控制台,console才会用,几乎没啥作用</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>实践出真知</p>
<h3 id="1-常规测试"><a href="#1-常规测试" class="headerlink" title="1. 常规测试"></a>1. 常规测试</h3><p>使用基本的表,插入基本的数据</p>
<img src="/2019/11/30/mysql%E4%B8%ADtinyint-1-%E5%92%8Ctinyint-4-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/basic_table.png" class="" title="基本表">

<p>查询后发现没有任何区别</p>
<img src="/2019/11/30/mysql%E4%B8%ADtinyint-1-%E5%92%8Ctinyint-4-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/basic_test.png" class="" title="基本测试">

<p>可以发现没有任何区别,实际上就是没有任何区别,如果你用navicat之类的工具试验,也会发现没有任何差别,详情可以参见引用<a href="http://stackoverflow.com/questions/12839927/mysql-tinyint-2-vs-tinyint1-what-is-the-difference" title="stackoverflow的链接" target="">stackoverflow用户AamirR的回答</a>里面Aamir的回答可以做很好的验证</p>
<h3 id="2-无符号建表-同时zerofill"><a href="#2-无符号建表-同时zerofill" class="headerlink" title="2. 无符号建表,同时zerofill"></a>2. 无符号建表,同时zerofill</h3><p>建表的基本语句是</p>
<img src="/2019/11/30/mysql%E4%B8%ADtinyint-1-%E5%92%8Ctinyint-4-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/unsigned_table.png" class="" title="无符号建表">
<p>最后查询结果如下,比较明显</p>
<img src="/2019/11/30/mysql%E4%B8%ADtinyint-1-%E5%92%8Ctinyint-4-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/unsigned_query.png" class="" title="无符号查询">

<p>zerofill的整数字段必须无符号,这里可以看出M显示出了特定的宽度,不够的时候会填充0,多余了不作处理</p>
<h2 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h2><p>这里查阅的官方文档是5.7英文版<a href="https://dev.mysql.com/doc/refman/5.7/en/numeric-type-attributes.html" title="官方文档的链接" target="">传送门</a></p>
<p>这里摘抄其中重要的一段</p>
<p>MySQL supports an extension for optionally specifying the display width of integer data types in parentheses following the base keyword for the type. For example, INT(4) specifies an INT with a display width of four digits. This optional display width may be used by applications to display integer values having a width less than the width specified for the column by left-padding them with spaces. (That is, this width is present in the metadata returned with result sets. Whether it is used or not is up to the application.)</p>
<p>The display width does not constrain the range of values that can be stored in the column. Nor does it prevent values wider than the column display width from being displayed correctly. For example, a column specified as SMALLINT(3) has the usual SMALLINT range of -32768 to 32767, and values outside the range permitted by three digits are displayed in full using more than three digits.</p>
<p>When used in conjunction with the optional (nonstandard) attribute ZEROFILL, the default padding of spaces is replaced with zeros. For example, for a column declared as INT(4) ZEROFILL, a value of 5 is retrieved as 0005.</p>
<p>至此,也验证了我们的结论.</p>
<ol>
<li>M绝对和存储的值没有关系</li>
<li>无符号和zerofill的时候会填充0,显示成M对应的宽度</li>
<li>整数类型都一样,有默认的显示宽度</li>
<li>M作为元数据存储,推荐是显示的宽度,但是最终的解释权归使用的程序所有</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最后,我的建议是,就是M其实没用,tinyint默认是4,其余的数字类型也有默认值,以后程序开发中,涉及整形数字的M时,可以不必纠结,直接忽略,使用数据库默认的M值即可</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu优化后跑分测试</title>
    <url>/2022/11/09/qemu%E4%BC%98%E5%8C%96%E5%90%8E%E8%B7%91%E5%88%86%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="qemu优化后跑分测试"><a href="#qemu优化后跑分测试" class="headerlink" title="qemu优化后跑分测试"></a>qemu优化后跑分测试</h1><p>前面写过一片文章,就是qemu优化,今天分享一下qemu拉满优化以后的跑分,用娱乐大师,看看效果如何</p>
<h2 id="话不多说-直接上图"><a href="#话不多说-直接上图" class="headerlink" title="话不多说,直接上图"></a>话不多说,直接上图</h2><img src="/2022/11/09/qemu%E4%BC%98%E5%8C%96%E5%90%8E%E8%B7%91%E5%88%86%E6%B5%8B%E8%AF%95/ludashi.PNG" class="" title="性能几乎没有损耗">

<p>解读一下,这个跑分</p>
<ol>
<li>cpu,9600k本来的平均跑分36w左右,这里30w,还用了4个核,其实是超常发挥的(<strong>这里是cpu pin,cpu设置和真机保持一致,避免了线程切换的损耗</strong>)</li>
<li>显卡跑分,rx460的跑分,本来就是8w左右的样子,看来这里的显卡直通,完整的发挥了硬件的性能,几乎没有任何的损耗(<strong>显卡直通</strong>)</li>
<li>内存跑分,内存跑分,这个不同的内存差距比较大,不过我的是ddr4 2666hz,我看网上的例子,单通道的ddr4 2666hz差不多是5w分(<strong>这里直接使用了大页内存,8个1g的内存,直接连续,减少了寻址的次数</strong>)</li>
<li>存储的分数,前面也有讲过,这个其实水分很大,因为连续读写用了缓存,是虚假的跑分,意义不大(<strong>virtIO虽然比不上存储直通,但是无论是sata和nvme的ssd的virtIO驱动,都是够用的,不会成为瓶颈</strong>)</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们前面的优化都是非常有效的,从cpu pin,再到使用大页的内存,再到显卡直通,几乎获得了一个和真机一样的虚拟机,而且从cpu,内存,再到存储,几乎没有短板(<strong>小心木桶效应</strong>),<br>我还用他来打游戏测试了,没错,一点也不卡,非常流畅,这样的机器,其实用起来,你都不觉得是一个虚拟机,因为非常快</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>manjaro使用qemu安装win10详细教程</title>
    <url>/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="manjaro使用qemu安装win10详细教程"><a href="#manjaro使用qemu安装win10详细教程" class="headerlink" title="manjaro使用qemu安装win10详细教程"></a>manjaro使用qemu安装win10详细教程</h1><p>主机是manjaro,使用qemu安装win10,以前那些文章,上来讲的都是怎么优化,而且并不是很详细,所以,这里,就详细的讲了如何安装win10</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>win10镜像,这里推荐win10的22h2版本</li>
<li>准备virtIO驱动,<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio" title="驱动下载地址" target="">驱动下载地址</a>,<br>找到最新的文件夹,直接下载<code>virtio-win.iso</code></li>
</ol>
<h2 id="manjaro安装qemu"><a href="#manjaro安装qemu" class="headerlink" title="manjaro安装qemu"></a>manjaro安装qemu</h2><h3 id="安装qemu"><a href="#安装qemu" class="headerlink" title="安装qemu"></a>安装qemu</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syu qemu-base virt-manager</span><br></pre></td></tr></table></figure>

<h3 id="设置libvirtd开机启动"><a href="#设置libvirtd开机启动" class="headerlink" title="设置libvirtd开机启动"></a>设置libvirtd开机启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable libvirtd.service</span><br><span class="line">sudo systemctl start libvirtd.service</span><br></pre></td></tr></table></figure>

<h3 id="允许普通用户使用qemu"><a href="#允许普通用户使用qemu" class="headerlink" title="允许普通用户使用qemu"></a>允许普通用户使用qemu</h3><p>修改libvirtd.conf配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># /etc/libvirt/libvirtd.conf</span><br><span class="line">unix_sock_group = &quot;libvirt&quot;</span><br><span class="line">unix_sock_rw_perms = &quot;0770&quot;</span><br></pre></td></tr></table></figure>

<p>添加当前用户到libvirt组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -a -G libvirt $(whoami)</span><br><span class="line">newgrp libvirt # 重新启动也可以,这里可选</span><br></pre></td></tr></table></figure>

<h2 id="准备文件"><a href="#准备文件" class="headerlink" title="准备文件"></a>准备文件</h2><p>这里我将文件下载好,分别是win10的22h2的iso,和virto-win的iso</p>
<ol>
<li><a href="https://next.itellyou.cn/" title="非官方下载地址" target="">win10的iso</a>下载`zh-cn_windows_10_business_editions_version_22h2_updated_nov_2022_x64_dvd_e310fb02.iso`,记得校验文件完整性</li>
<li><a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio" title="驱动下载地址" target="">驱动下载地址</a>下载最新版本的`virtio-win.iso`</li>
</ol>
<h2 id="设置虚拟机"><a href="#设置虚拟机" class="headerlink" title="设置虚拟机"></a>设置虚拟机</h2><p>选择手动安装</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/step1.png" class="" title="第一步">
<p>选择win10</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/step2.png" class="" title="第二步">
<p>设置cpu和内存</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/step3.png" class="" title="第三步">
<p>后面我们自己设置存储</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/step4.png" class="" title="第四步">
<p>这里一定要选择自定义安装</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/step5.png" class="" title="第五步">
<p>添加virtio存储,选择<code>add hardware</code>,<code>storage</code>里面,存储大小看自己的需求而定,注意,一般选择不必选择立马分配区间,这样会造成浪费,而且后期不够了,也可以扩展的</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/disk_virtio.png" class="" title="virtio存储">
<p>修改网络驱动为virtio,这样会导致安装的时候,没有网络,不过没关系,以后安装驱动了以后就可以出来了,</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/network_virtio.png" class="" title="virtio网络">
<p>添加virtio存储,选择<code>add hardware</code>,<code>storage</code>里面添加cd,选择<code>virtio-win.iso</code></p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/cd1.png" class="" title="添加virtio-win.iso">
<p>添加virtio存储,选择<code>add hardware</code>,<code>storage</code>里面添加cd,选择<code>zh-cn_windows_10_business_editions_version_22h2_updated_nov_2022_x64_dvd_e310fb02.iso</code>,这里我们就有了2个cd</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/cd2.png" class="" title="添加win10镜像">
<p>修改启动顺序</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/boot_order.png" class="" title="选择启动的win10镜像">
<p>最后开始安装</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/begin_install.png" class="" title="开始安装">

<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>开机的时候会提示我们任意键进入使用cd启动,我一般习惯按空格键,装机的时候,一定要选择自定义</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/custom_install.png" class="" title="自定义安装">
<p>这时候我们会看到竟然没有存储可以安装系统,如果你有使用vmware或者virtualbox的体验的话,可能觉得不太对劲,不过没关系</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/no_storage.png" class="" title="暂时没有驱动">
<p>选择加载驱动</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/load_driver.png" class="" title="选择加载驱动">
<p>选择浏览</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/load_driver_browse.png" class="" title="选择浏览">
<p>接下来选择我们的<code>virtio-win.iso</code>,找到<code>viostor</code>,选择<code>win10</code>,<code>x86</code>,然后安装</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/right_driver.png" class="" title="选择正确驱动">
<p>接下来,我们就能看到出现了我们加的virtio存储</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/disk_show.png" class="" title="存储出现">

<h2 id="系统安装完成后-安装驱动"><a href="#系统安装完成后-安装驱动" class="headerlink" title="系统安装完成后,安装驱动"></a>系统安装完成后,安装驱动</h2><p>因为我们选择的是<code>virtio</code>的网络驱动,所以一开始是没有网络的,如果我们选择<code>e1000e</code>这个驱动,就有网络,但是性能没有<code>virtio</code>的好,不过没关系,我们安装一下驱动就好了</p>
<img src="/2022/11/27/manjaro%E4%BD%BF%E7%94%A8qemu%E5%AE%89%E8%A3%85win10%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/install_windows_driver.png" class="" title="安装windows驱动">
<p>安装完成后,它还会自动安装<code>spice</code>驱动,此时,我们鼠标和键盘可以自动捕获,而且也可以实现复制粘贴的传递,类似于<code>virtualbox</code>的增加工具,vmware的<code>vmware tools</code>,<br>体验直接上升一大截</p>
<h2 id="linux主机和windows文件共享"><a href="#linux主机和windows文件共享" class="headerlink" title="linux主机和windows文件共享"></a>linux主机和windows文件共享</h2><p>使用linux的samba,详情可以参考arch的samba文档</p>
<h2 id="开始优化"><a href="#开始优化" class="headerlink" title="开始优化"></a>开始优化</h2><p>现在虚拟机已经安装安全,接下来,可以参考我前面的几篇文章优化,或者进行显卡直通,最终将会体验翻倍,堪比真机</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇从0到1的展示了,在一个manjaro系统,如何使用qemu安装win10,定位就是详细教程,可以看到里面有大量的截图,希望能帮到你</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu全方位优化指南</title>
    <url>/2022/11/08/qemu%E5%85%A8%E6%96%B9%E4%BD%8D%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="qemu全方位优化指南"><a href="#qemu全方位优化指南" class="headerlink" title="qemu全方位优化指南"></a>qemu全方位优化指南</h1><p>qemu优化和不优化差距很大,优化好了,几乎和真机一样的体验</p>
<p>本篇文章的每一个章节,铺开了讲,都能写好几章,所以,这里不涉及原理,只提供思路和参考,具体的实践,你还要通过多搜一下才能达到</p>
<h2 id="优化的思路"><a href="#优化的思路" class="headerlink" title="优化的思路"></a>优化的思路</h2><img src="/2022/11/08/qemu%E5%85%A8%E6%96%B9%E4%BD%8D%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/%E5%A4%A9%E4%B8%8B%E6%AD%A6%E5%8A%9F.jpeg" class="" title="天下武功,无坚不破,唯快不破">

<p>一个电脑快,到底是什么促成了一个电脑快,首先cpu强大,再内存够用,然后存储的io跟的上,然后网络要快,2d和3d的性能要强劲,总共就这几个方向</p>
<ol>
<li>cpu强大</li>
<li>内存够用</li>
<li>存储io要快</li>
<li>网络io要快</li>
<li>图形性能要强大,包括2d和3d的支持</li>
</ol>
<h2 id="qemu优化"><a href="#qemu优化" class="headerlink" title="qemu优化"></a>qemu优化</h2><ol>
<li>cpu pin</li>
<li>cpu数量优化</li>
<li>使用huagepages</li>
<li>hyperv相关优化</li>
<li>安装virtio-win驱动,改善易用性,相当于vmware或者virtualbox的增强工具</li>
<li>有机后了,如果你一个集显,一个独显,可以显卡passthough,补上虚拟机3d性能的遗憾</li>
</ol>
<h3 id="cpu优化"><a href="#cpu优化" class="headerlink" title="cpu优化"></a>cpu优化</h3><h4 id="cpu-pin"><a href="#cpu-pin" class="headerlink" title="cpu pin"></a>cpu pin</h4><p>cpu pin以后,可以让cpu和线程绑定起来,然后减少上下文切换</p>
<p>这里以我的cpu为例,i5-9600k,总共6个核心,我给他们分配了4个,剩下2个,一个分给了emulatorpin,<br>一个分给了iothreadpin,实际使用了还是6个核心,具体cpu pin,需要看自己的cpu数量和是否支持超线程来定,<br>还是比较复杂的,这里给了是一个示例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&quot;static&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iothreads</span>&gt;</span>1<span class="tag">&lt;/<span class="name">iothreads</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cputune</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vcpupin</span> <span class="attr">vcpu</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cpuset</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vcpupin</span> <span class="attr">vcpu</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cpuset</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vcpupin</span> <span class="attr">vcpu</span>=<span class="string">&quot;2&quot;</span> <span class="attr">cpuset</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">vcpupin</span> <span class="attr">vcpu</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cpuset</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">emulatorpin</span> <span class="attr">cpuset</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iothreadpin</span> <span class="attr">iothread</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cpuset</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cputune</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="cpu核心数量确定"><a href="#cpu核心数量确定" class="headerlink" title="cpu核心数量确定"></a>cpu核心数量确定</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpu</span> <span class="attr">mode</span>=<span class="string">&quot;host-passthrough&quot;</span> <span class="attr">check</span>=<span class="string">&quot;none&quot;</span> <span class="attr">migratable</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">topology</span> <span class="attr">sockets</span>=<span class="string">&quot;1&quot;</span> <span class="attr">dies</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cores</span>=<span class="string">&quot;4&quot;</span> <span class="attr">threads</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cache</span> <span class="attr">mode</span>=<span class="string">&quot;passthrough&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>使用hugepages,使用连续的内存,同时减少查询的次数</p>
<p>开启1g大页内存,数量为8,grub的增加GRUB_CMDLINE_LINUX_DEFAULT以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;default_hugepagesz=1G hugepagesz=1G hugepages=8&quot;</span><br></pre></td></tr></table></figure>

<p>挂载分区,&#x2F;etc&#x2F;fstab,加以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">none                                      /mnt/huge      hugetlbfs pagesize=1G,size=8G 0 0</span><br></pre></td></tr></table></figure>

<p>虚拟机配置使用,使用默认的大页内存,我们开了8个1g的大分页,总共8g内存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hugepages</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="io优化"><a href="#io优化" class="headerlink" title="io优化"></a>io优化</h3><p>存储类型选择virtIO驱动,网络类型也选择virtIO模式</p>
<h3 id="针对windows的虚拟机优化"><a href="#针对windows的虚拟机优化" class="headerlink" title="针对windows的虚拟机优化"></a>针对windows的虚拟机优化</h3><p>这是微软为了提高windows在hyper模式下所做的优化,windows知道自己是作为虚拟机了,主动做的一些优化,qemu也支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hyperv</span> <span class="attr">mode</span>=<span class="string">&quot;custom&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">vpindex</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">runtime</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">synic</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">stimer</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">direct</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">stimer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reset</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frequencies</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reenlightenment</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">hyperv</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3d性能优化"><a href="#3d性能优化" class="headerlink" title="3d性能优化"></a>3d性能优化</h3><p>安装virtio-win里面驱动,里面包含了virtIO的驱动,同时也包含了spice-guest-tools,可以增加一些2d的性能,包含少量的3d性能,如果想要增加3d<br>性能,只能pcie passthough了,就是直接分配给虚拟机一块显卡,然后虚拟机装上驱动,就可以差不多拥有和真机一样的3d性能,因为此时,已经完整的包含了一张<br>显卡设备</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面几个看似不起眼的优化,其实每个对性能的提升都是非常巨大的,基本上你按照以上的优化实施以后,虚拟机可以达到真机的水平,尤其是显卡 passthough<br>以后,虚拟机最后一个3d的短板也被修补上,将会非常流畅</p>
<p>经过这些优化,没错,你的虚拟机可以直接玩3d游戏了(需要显卡passthough),也会不卡</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu各种存储类型io大比拼</title>
    <url>/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/</url>
    <content><![CDATA[<h1 id="qemu各种存储类型io大比拼"><a href="#qemu各种存储类型io大比拼" class="headerlink" title="qemu各种存储类型io大比拼"></a>qemu各种存储类型io大比拼</h1><p>qemu是linux的虚拟机,负责虚拟化一个机器出来,包括cpu,内存,pci,存储,网卡之类的,但是纯模拟效率比较低,所以,一般和kvm配合,<br>kvm负责虚拟内核,然后qemu继续负责外围,所以,qemu-kvm是linux平台的主流虚拟机,性能也是相当高</p>
<p>今天就来介绍一下,qemu的各种io类型的跑分,首先,先说结论,virtIO的性能也是非常好的,可以做到够用,但是想要强,还是要PCI passthough,花不多说,上图吧</p>
<h2 id="talk-is-cheap-show-me-the-benchmark"><a href="#talk-is-cheap-show-me-the-benchmark" class="headerlink" title="talk is cheap,show me the benchmark"></a>talk is cheap,show me the benchmark</h2><p>这些图片是引用了一个up主的视频<a href="https://www.youtube.com/watch?v=oSpGggczD2Y&t=602s&ab_channel=PavolElsig" title="up主做的" target="">Adding VirtIO and passthrough storage in Virtual Machine Manager</a>  </p>
<p>这些跑分应该这样解读,顺序读写看着很快,其实只有大文件读写才用得到,主要还是看4k的速度,4k的速度,单线程和多线程都很重要,上面两个是顺序,下面两个是4k,<br>所以,virtio默认带缓存的时候,看起来顺序读写很吓人,其实没太大用处</p>
<ol>
<li>all表示执行全部任务</li>
<li>SEQ1M|Q8T1表示顺序读写，位深1024K，1线程8队列的测试速度</li>
<li>SEQ1M|Q1T1表示顺序读写，位深1024K，1线程1队列测试速度</li>
<li>RND4K|Q32T16表示随机读写，位深1024*4K，16线程32队列的测试速度</li>
<li>RND4K|Q1T1表示随机读写，位深1024*4K，一线程一队列的测试速度</li>
</ol>
<h3 id="SATA模式"><a href="#SATA模式" class="headerlink" title="SATA模式"></a>SATA模式</h3><p>装机的时候,可以直接识别,不需要驱动安装</p>
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/sata-no-cache-config.png" class="" title="stat no cache config">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/sata-no-cache.png" class="" title="stat no cache benchmark">

<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/sata-default-cache-config.png" class="" title="stat default config">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/sata-default-cache.png" class="" title="stat default benchmark">

<h3 id="LNU-passthrough"><a href="#LNU-passthrough" class="headerlink" title="LNU passthrough"></a>LNU passthrough</h3><img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/lnu-passthrough-config.png" class="" title="LNU passthrough config">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/lnu-passthrough.png" class="" title="LNU passthrough benchmark">

<h3 id="virtIO模式"><a href="#virtIO模式" class="headerlink" title="virtIO模式"></a>virtIO模式</h3><p>需要驱动</p>
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/virtio-no-cache-config.png" class="" title="virtIO no cache config">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/virtio-no-cache.png" class="" title="virtIO benchmark">

<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/virtio-default-config.png" class="" title="virtIO default config">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/virtio-default.png" class="" title="virtIO default benchmark">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/virtio-default-cache-full.png" class="" title="virtIO default 缓存用尽 benchmark">

<h3 id="PCI-passthrough"><a href="#PCI-passthrough" class="headerlink" title="PCI passthrough"></a>PCI passthrough</h3><p>不需要驱动</p>
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/nvem-config.png" class="" title="nvme config">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/nvme.png" class="" title="nvme benchmark">

<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/stat-config.png" class="" title="sata ssd config">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/stat.png" class="" title="sata ssd benchmark">

<h3 id="自己机器的PCI-passthrough"><a href="#自己机器的PCI-passthrough" class="headerlink" title="自己机器的PCI passthrough"></a>自己机器的PCI passthrough</h3><img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/hp-ssd-m700.PNG" class="" title="hp ssd s700 虚拟机 passthrough benchmark">
<img src="/2022/10/26/qemu%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8Bio%E5%A4%A7%E6%AF%94%E6%8B%BC/hp-ssd-s700-500g-origin.jpg" class="" title="hp ssd s700真机 benchmark">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简要总结,sata怎么样都不行,LNU passthrough还是不行,只有virtIO最好,当然passThrough才是最强王者  </p>
<p>平常使用的时候,virtIO就可以了,有条件一定要passThrough</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">成绩</th>
<th align="center">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sata</td>
<td align="center">差</td>
<td align="center">装系统的时候不要驱动,但是性能不行,我还是装驱动吧,不过它也有自己的场景,适用于有些系统无法装驱动,比如说qemu装androidx86的时候,就无法装virtIO驱动,所以只能使用这种方式</td>
</tr>
<tr>
<td align="center">lnu passthrough</td>
<td align="center">较差</td>
<td align="center">可以利用一个分区,但是性能还是不行,我这样用还不如用virtIO的文件</td>
</tr>
<tr>
<td align="center">virtIO</td>
<td align="center">良</td>
<td align="center">可以,顺序读写不差多少,但是4k读写一半左右的性能,还不错,其实已经够用,在虚拟机里面算水平很高了</td>
</tr>
<tr>
<td align="center">PCI passthrough</td>
<td align="center">优</td>
<td align="center">只能一个sdd整个一起用,但是性能非常好,能达到80-90%的性能,有条件一定要整</td>
</tr>
</tbody></table>
<p>用PCI passthrough的时候,可以看到sata的ssd速度能达到原生的80-90%(4k的多线程读写,up主80%没,我的是90%,平常还是用读的比较多),但是NVME的ssd性能损耗比较大,因为本来就很快,即便降低了1&#x2F;3,<br>其实还是比普通的sata的ssd快,还是比较可惜,PCI passthough需要开启IOMMU,而且只能一下用整个存储,但是我还是推荐你使用,性能非常好</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu显卡直通详细教程</title>
    <url>/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="qemu显卡直通详细教程"><a href="#qemu显卡直通详细教程" class="headerlink" title="qemu显卡直通详细教程"></a>qemu显卡直通详细教程</h1><p>虚拟机的3d性能,除了直通以外,都是模拟的,性能一般有好有坏,无论是virtualbox还是vmware,其实他们的3d性能,不论好与坏,都是模拟的驱动,<br>这点你可以通过windows的设备管理器看出来,与真实的差距其实还是不小的,2d的游戏可以玩,但是3d的游戏,就算是能玩,综合各方面的因素,体验也是上不去的,<br>所以,<strong>如果你想要一个强大的虚拟机,显卡直通是必然的,只有这一条路</strong>,只有显卡直通以后,3d性能变成原生的,你的虚拟机,才会没有短板,综合体验也上去</p>
<h2 id="什么是显卡直通"><a href="#什么是显卡直通" class="headerlink" title="什么是显卡直通"></a>什么是显卡直通</h2><p>显卡直通拿qemu为列,就是linux启动的时候,一张独显,不加载驱动,保留下来,然后虚拟机启动以后直接使用,到时候虚拟机的显卡驱动,直接就是对应显卡型号<br>的原生驱动</p>
<img src="/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/%E5%8E%9F%E7%94%9F%E9%A9%B1%E5%8A%A8.png" class="" title="rx560显卡的windows驱动">

<h2 id="显卡直通需要具备什么条件"><a href="#显卡直通需要具备什么条件" class="headerlink" title="显卡直通需要具备什么条件"></a>显卡直通需要具备什么条件</h2><p>显卡直通也分很多种,比如单显卡直通,双显卡直通,但是双显卡直通是最优的,一般是主机使用集显,虚拟机使用独显(反过来可以吗,我没试过,也可能因为技术原因根本就没法反过来),以我自身为例,双显卡,双显示器</p>
<ol>
<li>cpu 9600k,带集显(一般bios有独显的时候,会默认屏蔽集显,需要把集显调成可用,这点需要注意)</li>
<li>amd的rx560显卡</li>
<li>最好有两个显示器,一个集显插口用,一个独显插口用,(注意,如果是4k显示器,集显需要用dp接口(hdmi低版本不支持4k60hz),如果没有两个显示器,到时候回流过来,也麻烦,我就没用这种)</li>
</ol>
<p>现在我就有了两张显卡,到时候,我会linux用集显,然后windows的虚拟机使用独显</p>
<h2 id="显卡直通以后-会带来什么新问题"><a href="#显卡直通以后-会带来什么新问题" class="headerlink" title="显卡直通以后,会带来什么新问题"></a>显卡直通以后,会带来什么新问题</h2><ol>
<li>显卡直通以后,你的linux主机,不能用另外一块显示器</li>
<li>你的虚拟机的声音,qemu的spice驱动就没法使用,你的虚拟机的声音需要回流过来</li>
<li>你的虚拟机,此时,qemu的spice驱动,也不会帮你同步鼠标和键盘,这个时候,你需要使用别的方案来操作另一台虚拟机</li>
</ol>
<p>不过,这些问题都不是事,接下来,都有完美的方案可以解决</p>
<h2 id="qemu显卡直通步骤"><a href="#qemu显卡直通步骤" class="headerlink" title="qemu显卡直通步骤"></a>qemu显卡直通步骤</h2><p>这里,我会以我的硬件为例,一步步的讲解我的直通步骤,参考资料是<a href="https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF" title="arch PCI passthrough via OVMF" target="">arch PCI passthrough via OVMF</a>,<br>arch的资料都写的非常详细,而且细节也照顾的很到位</p>
<h3 id="更新你的系统-确保你的内核更新"><a href="#更新你的系统-确保你的内核更新" class="headerlink" title="更新你的系统,确保你的内核更新"></a>更新你的系统,确保你的内核更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">manjaro 更新系统</span></span><br><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure>

<h3 id="开启IOMMU"><a href="#开启IOMMU" class="headerlink" title="开启IOMMU"></a>开启IOMMU</h3><p>我是intel的cpu,需要手动开启,amd的cpu,默认开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/default/grub</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For Intel CPUs (VT-d) <span class="built_in">set</span> intel_iommu=on. Since the kernel config option CONFIG_INTEL_IOMMU_DEFAULT_ON is not <span class="built_in">set</span> <span class="keyword">in</span> linux.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">iommu=pt You should also append the iommu=pt parameter. This will prevent Linux from touching devices <span class="built_in">which</span> cannot be passed through.</span></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;... intel_iommu=on iommu=pt ...&quot;</span><br></pre></td></tr></table></figure>

<h3 id="查找显卡所在的iommu-group"><a href="#查找显卡所在的iommu-group" class="headerlink" title="查找显卡所在的iommu group"></a>查找显卡所在的iommu group</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">shopt -s nullglob</span><br><span class="line">for g in $(find /sys/kernel/iommu_groups/* -maxdepth 0 -type d | sort -V); do</span><br><span class="line">    echo &quot;IOMMU Group $&#123;g##*/&#125;:&quot;</span><br><span class="line">    for d in $g/devices/*; do</span><br><span class="line">        echo -e &quot;\t$(lspci -nns $&#123;d##*/&#125;)&quot;</span><br><span class="line">    done;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>

<p>部分输出如下,可以看到我的显在group 1</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IOMMU Group 0:</span><br><span class="line">        00:00.0 Host bridge [0600]: Intel Corporation 8th Gen Core Processor Host Bridge/DRAM Registers [8086:3ec2] (rev 0a)</span><br><span class="line">IOMMU Group 1:</span><br><span class="line">        00:01.0 PCI bridge [0604]: Intel Corporation 6th-10th Gen Core Processor PCIe Controller (x16) [8086:1901] (rev 0a)</span><br><span class="line">        01:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Baffin [Radeon RX 460/560D / Pro 450/455/460/555/555X/560/560X] [1002:67ef] (rev cf)</span><br><span class="line">        01:00.1 Audio device [0403]: Advanced Micro Devices, Inc. [AMD/ATI] Baffin HDMI/DP Audio [Radeon RX 550 640SP / RX 560/560X] [1002:aae0]</span><br><span class="line">IOMMU Group 2:</span><br><span class="line">        00:02.0 VGA compatible controller [0300]: Intel Corporation CoffeeLake-S GT2 [UHD Graphics 630] [8086:3e98]</span><br><span class="line">IOMMU Group 3:</span><br><span class="line">        00:08.0 System peripheral [0880]: Intel Corporation Xeon E3-1200 v5/v6 / E3-1500 v5 / 6th/7th/8th Gen Core Processor Gaussian Mixture Model [8086:1911]</span><br></pre></td></tr></table></figure>

<h3 id="隔离GPU"><a href="#隔离GPU" class="headerlink" title="隔离GPU"></a>隔离GPU</h3><h4 id="绑定设备id"><a href="#绑定设备id" class="headerlink" title="绑定设备id"></a>绑定设备id</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># /etc/modprobe.d/kvm.conf</span><br><span class="line"># 防止Windows 10 1803蓝屏</span><br><span class="line">options kvm ignore_msrs=1</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># /etc/modprobe.d/vfio.conf</span><br><span class="line"># 按隔离整组组设备</span><br><span class="line">options vfio-pci ids=8086:1901,1002:67ef,1002:aae0</span><br></pre></td></tr></table></figure>

<p>注意一下事项</p>
<ol>
<li>绑定都是需要绑定整个group所有设备</li>
</ol>
<h4 id="提前加载驱动"><a href="#提前加载驱动" class="headerlink" title="提前加载驱动"></a>提前加载驱动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/mkinitcpio.conf</span></span><br><span class="line">MODULES=(... vfio_pci vfio vfio_iommu_type1 vfio_virqfd ...)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">manjaro hooks 里面已经有了 modconf,所以,不需要再添加了</span></span><br><span class="line">HOOKS=(... modconf ...)</span><br></pre></td></tr></table></figure>

<h4 id="重新构建-让配置生效"><a href="#重新构建-让配置生效" class="headerlink" title="重新构建,让配置生效"></a>重新构建,让配置生效</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkinitcpio -P</span><br></pre></td></tr></table></figure>

<h3 id="重启-验证配置"><a href="#重启-验证配置" class="headerlink" title="重启,验证配置"></a>重启,验证配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lspci -nnk</span><br></pre></td></tr></table></figure>
<p>输出部分如下,可以看到,现在驱动都使用vfio-pci,表明成功,至此,已经提前做好了所有的准备</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">01:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Baffin [Radeon RX 460/560D / Pro 450/455/460/555/555X/560/560X] [1002:67ef] (rev cf)</span><br><span class="line">        Subsystem: Hightech Information System Ltd. Device [1787:3000]</span><br><span class="line">        Kernel driver in use: vfio-pci</span><br><span class="line">        Kernel modules: amdgpu</span><br><span class="line">01:00.1 Audio device [0403]: Advanced Micro Devices, Inc. [AMD/ATI] Baffin HDMI/DP Audio [Radeon RX 550 640SP / RX 560/560X] [1002:aae0]</span><br><span class="line">        Subsystem: Hightech Information System Ltd. Device [1787:aae0]</span><br><span class="line">        Kernel driver in use: vfio-pci</span><br><span class="line">        Kernel modules: snd_hda_intel</span><br></pre></td></tr></table></figure>

<h3 id="qemu设置PCI直通"><a href="#qemu设置PCI直通" class="headerlink" title="qemu设置PCI直通"></a>qemu设置PCI直通</h3><h4 id="amd-gpu-hyperv-检测"><a href="#amd-gpu-hyperv-检测" class="headerlink" title="amd gpu hyperv 检测"></a>amd gpu hyperv 检测</h4><p>这里需要设置允许xml编辑</p>
<img src="/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/enable_xml_edit.png" class="" title="virt-manager设置允许xml编辑">

<p>支持hyperv检测gpu,这里是一个优化</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">acpi</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">apic</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hyperv</span> <span class="attr">mode</span>=<span class="string">&quot;custom&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relaxed</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vapic</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spinlocks</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;8191&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vpindex</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">runtime</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">synic</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stimer</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">direct</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">stimer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reset</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor_id</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span> <span class="attr">value</span>=<span class="string">&quot;notavm&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 就是这一句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frequencies</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reenlightenment</span> <span class="attr">state</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">hyperv</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vmport</span> <span class="attr">state</span>=<span class="string">&quot;off&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="video-qxl-添加PCIe"><a href="#video-qxl-添加PCIe" class="headerlink" title="video qxl,添加PCIe"></a>video qxl,添加PCIe</h4><p>先使用模拟显卡</p>
<img src="/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/video_qxl.png" class="" title="先使用video_qxl设备">
<p>添加PCI设备,把整组加上,我的组有个PCIe Controller,不用加</p>
<img src="/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/add_pci.png" class="" title="添加PCIe设备">

<h4 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h4><p>windows一般会自动安装驱动,上面安装好驱动以后,另一个屏幕,接得独显接口这个显示器,就会亮,这个时候,就是独显驱动安装好了</p>
<h4 id="video-none启动"><a href="#video-none启动" class="headerlink" title="video none启动"></a>video none启动</h4><p>然后我们就可以去掉虚拟显卡</p>
<img src="/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/video_none.png" class="" title="不使用虚拟显卡">
<p>这个时候,启动之前,你需要至少给虚拟机添加一个usb鼠标,添加一个<code>usb host device</code>即可,这样才可以控制你的电脑,如果有密码的话,使用屏幕键盘即可,<br>这样整个独显直通就做好了,但是还有两个问题,需要解决,上面已经提到了</p>
<h3 id="添加鼠标和键盘"><a href="#添加鼠标和键盘" class="headerlink" title="添加鼠标和键盘"></a>添加鼠标和键盘</h3><p>不论你豪不豪,分别用两套鼠标和键盘都不是好的方案,以下有几种方案</p>
<ol>
<li>硬件切换,如带kvm切换器的鼠标键盘,需要按一下,不好</li>
<li>现在有些蓝牙键盘和鼠标,也是支持多设备,但是人家是蓝牙的,我们这里模拟蓝牙设备就算了</li>
<li>最好的方案,应该是软件方案,代表作就是barrier(开源免费)和synergy(开始开源,后面收费了,但是你可以自己编译)</li>
</ol>
<p>这里我们选择开源的barrier,只需要主机和虚拟机都装好,配好,然后,就可以直接一个鼠标划到另外一个屏幕了,非常方便,不用任何切换,而且比局域网还快的速度,没有任何延迟</p>
<img src="/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/barrier.png" class="" title="barrier配置">
<p>可以看到,我的两个屏幕,主机的屏幕在左边,虚拟机的屏幕在右边,比如你玩游戏的时候,想把你的鼠标锁到虚拟机里面,按下<code>scroll lock</code>就好了,这样就能把他锁进去了,经过我这么长时间的体验,发现,<br>barrier鼠标没有任何延迟,文字复制粘贴没有任何问题,图片粘贴容易出问题,我把图片粘贴禁用了,这样就完全没问题了</p>
<h3 id="虚拟机声音广播到主机"><a href="#虚拟机声音广播到主机" class="headerlink" title="虚拟机声音广播到主机"></a>虚拟机声音广播到主机</h3><p>开源的广播声卡,可以把你虚拟机的声音广播到你的主机,效果非常棒,具体的原理就是虚拟机的声音,通过局域网(<strong>注意,此时,你的虚拟机必须使用桥接网卡模式</strong>),广播到你的主机linux,然后类似你主机linux的一个程序再放声音</p>
<img src="/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/bridge_network.png" class="" title="使用桥接网卡">
<a href="https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF" title="Scream" target="">Scream - Virtual network sound card for Microsoft Windows</a>

<p>这个项目,帮你编译scream,然后设置成开机启动,这样你虚拟机的声音都可以广播到主机了,同时你windows也安装好了scream,并且设置为scream为主声卡</p>
<a href="https://github.com/pavolelsig/Scream_helper" title="Scream Helper" target="">Scream Helper</a>

<h3 id="主机和虚拟机文件共享"><a href="#主机和虚拟机文件共享" class="headerlink" title="主机和虚拟机文件共享"></a>主机和虚拟机文件共享</h3><p>linux的samba,就是专门解决linux和windows文件共享的问题的</p>
<p>我的设置如下,samba和windows共享的时候,还可以支持软连接,我的配置如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/samba/smb.conf</span><br><span class="line">[global]</span><br><span class="line">    workgroup = workgroup</span><br><span class="line">    server string = manjaro</span><br><span class="line">    security = user</span><br><span class="line">    allow insecure wide links = yes </span><br><span class="line">[share]</span><br><span class="line">   comment = share</span><br><span class="line">   path = /home/ss/share</span><br><span class="line">   public = yes</span><br><span class="line">   writable = yes</span><br><span class="line">   printable = no</span><br><span class="line">   follow symlinks = yes</span><br><span class="line">   wide links = yes</span><br></pre></td></tr></table></figure>

<p>最后的效果如下</p>
<img src="/2022/11/27/qemu%E6%98%BE%E5%8D%A1%E7%9B%B4%E9%80%9A%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/%E6%98%A0%E5%B0%84%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8.png" class="" title="我把它映射成网络驱动了">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过各种设置,我们准备了显卡直通的条件,然后,虚拟机安装驱动以后,我们又把声音和鼠标键盘的问题,搞定了,总之,折腾吧<br>最后,如果遇到问题,可以参考这个资料,arch的资料写的非常详细,非常好<a href="https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF" title="arch PCI passthrough via OVMF" target="">arch PCI passthrough via OVMF</a>,<br>这里我把链接再贴一次</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>显卡直通</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu简介</title>
    <url>/2022/10/26/qemu%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="qemu简介"><a href="#qemu简介" class="headerlink" title="qemu简介"></a>qemu简介</h1><p>QEMU开源,是一个托管的虚拟机，它通过动态的二进制转换，模拟CPU，并且提供一组设备模型，使它能够运行多种未修改的客户机OS，可以通过与KVM一起使用进而接近本地速度运行虚拟机（接近真实电脑的速度）。  </p>
<p>QEMU还可以为user-level的进程执行CPU仿真，进而允许了为一种架构编译的程序在另外一种架构上面运行（借由VMM的形式）。</p>


<h2 id="kvm"><a href="#kvm" class="headerlink" title="kvm"></a>kvm</h2><p>基于内核的虚拟机（英语：Kernel-based Virtual Machine，缩写为KVM）是一种用于Linux内核中的虚拟化基础设施，可将Linux内核转化为一个虚拟机监视器。KVM于2007年2月5日被导入Linux 2.6.20核心中。KVM需要支持硬件虚拟化拓展特性的处理器。</p>
<h2 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu-kvm"></a>qemu-kvm</h2><p>qemu负责外围设备,比如存储可以直通,然后kvm负责虚拟内核,qemu-kvm,再加上一些其它的优化,其中显卡也可以直通,可以获得几乎真机80-90%的性能,非常强大</p>
<h2 id="其它常见的面向用户的虚拟机"><a href="#其它常见的面向用户的虚拟机" class="headerlink" title="其它常见的面向用户的虚拟机"></a>其它常见的面向用户的虚拟机</h2><p>virtualbox和vmware也是两款强大的虚拟机,并且开箱易用,一般情况下是够用的,但是和qemu-kvm,比起来,几乎没法比较,尤其是优化拉满的<br>qemu-kvm虚拟机,几乎和真机一样强大,不过qemu需要自己了解一些常见的优化,而且并不是那样开箱易用</p>
<p>还有其它类型的虚拟机,但是面向的是专业人士,不是普通的用户,这里就不提了,但是虚拟机还是有很多种,每种也有很多类</p>
<h1 id="qemu-kvm真强"><a href="#qemu-kvm真强" class="headerlink" title="qemu-kvm真强"></a>qemu-kvm真强</h1><p>qemu-kvm这对组合,非常强大,因为我是使用linux系统作为办公,windows也是必不可少的,所以,我以前是virtualbox和vmware的重度用户,那时候我为了追求<br>虚拟机的性能,一般都是用的win8.1的32位系统,后来现在慢慢32位被淘汰了以后,我用了win10的64位虚拟机,先是virtualbox不能用,后是vmware间接性卡,<br>所以,我转向qemu,经常一段时间的摸索以后,我发现,比起这两个,强太多了,简直可以媲美真机,而且占用的损耗也非常低,所以,接下来,我会把握这一段事件的收获分享一下,带大家感受一下强大的qemu-kvm</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>shardingsphere简要介绍</title>
    <url>/2022/03/02/shardingsphere%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="shardingsphere简要介绍"><a href="#shardingsphere简要介绍" class="headerlink" title="shardingsphere简要介绍"></a>shardingsphere简要介绍</h1><p>可以做什么</p>
<table>
<thead>
<tr>
<th>分布式数据库</th>
<th>数据安全</th>
<th>数据库网关</th>
<th>全链路压测</th>
</tr>
</thead>
<tbody><tr>
<td>数据分片</td>
<td>数据加密</td>
<td>异构数据库支持</td>
<td>影子库</td>
</tr>
<tr>
<td>读写分离</td>
<td>行级权限（TODO）</td>
<td>SQL 方言转换（TODO）</td>
<td>可观测性</td>
</tr>
<tr>
<td>分布式事务</td>
<td>SQL 审计（TODO）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>弹性伸缩</td>
<td>SQL 防火墙（TODO）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>高可用</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="ShardingSphere-JDBC"><a href="#ShardingSphere-JDBC" class="headerlink" title="ShardingSphere-JDBC"></a>ShardingSphere-JDBC</h3><p><strong>本文基于当时最新版本5.1.0</strong></p>
<p>定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p>
<ol>
<li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC；</li>
<li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, HikariCP 等；</li>
<li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，PostgreSQL，Oracle，SQLServer 以及任何可使用 JDBC 访问的数据库。</li>
</ol>
<img style="background-color: aqua" src="./logo_v2.png" alt="shardingsphere logo" title="shardingsphere logo">

<h3 id="分布式数据库漫谈"><a href="#分布式数据库漫谈" class="headerlink" title="分布式数据库漫谈"></a>分布式数据库漫谈</h3><p>现在是互联网的时代,网络乘几何增长,随之而来的数据更是如此.铺天盖地的请求到来的是时候,首先是应用抗压,应用抗压以后,压力马上会到数据库,所以,<strong>对于数据库来说,<br>无论如何都是承受压力的点</strong>  </p>
<p>所以,诞生了以下需求</p>
<ol>
<li>高可用</li>
<li>高并发</li>
<li>海量数据</li>
</ol>
<p>诞生了以下概念</p>
<ol>
<li>olap</li>
<li>oltp</li>
<li>htap(Hybrid transaction&#x2F;analytical processing),上面两种混合,就是全能的意思</li>
</ol>
<p>OLTP（on-line transaction processing）翻译为联机事务处理， OLAP（On-Line Analytical Processing）翻译为联机分析处理，从字面上来看OLTP是做事务处理，<br>OLAP是做分析处理。从对数据库操作来看，OLTP主要是对数据的增删改，OLAP是对数据的查询,olap的解决方案之一就是大数据</p>
<ol>
<li>传统的关系型数据库都是单机的,当数据量大的时候,使用分库分表既可以简单的满足需求,这是其中的一种方案,典型的就是shardingsphere</li>
<li>Greenplum把传统的关系型数据库集合到一起,提供统一的接口,自动形成分布式数据库</li>
<li>tidb等,架构上就是分布式数据库,而不是传统的单机数据库通过调度实现分布式数据库</li>
</ol>
<p>上面三种,第一种,实在应用层实现分布式数据库,具体的实现由中间件实现,剩下的两种都是本身就是分布式数据库,但是实现的方式不太一样,</p>
<p>我们了解到了,我们需要一个强大的数据库,来支撑应用,支撑业务</p>
<p>ShardingSphere-jdbc在应用层,以中间件的方式,让大家将几个数据库当成一个用,实现了分布式数据库,不过,一般称之为分库分表</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>项目我已经发布到gitee了 <a href="https://gitee.com/david0624/shardingsphere-test">shardingsphere-demo</a></p>
<ol>
<li>maven添加依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>规则配置,使用yaml配置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">props:</span></span><br><span class="line">  <span class="attr">sql-show:</span> <span class="literal">true</span> <span class="comment"># 可以显示sql,显示的格式很不错</span></span><br></pre></td></tr></table></figure></li>
<li>创建数据源,注入数据源</li>
<li>接下来就是使用jdbc框架,如mybatis-plus</li>
<li>构造一些简单查询,就可以开始了</li>
</ol>
<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>简单分库查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  ShardingSphere-SQL - Logic SQL: SELECT id,teacherId,name FROM student WHERE id=? </span><br><span class="line">INFO  ShardingSphere-SQL - SQLStatement: MySQLSelectStatement(table=Optional.empty, limit=Optional.empty, lock=Optional.empty, window=Optional.empty)</span><br><span class="line">INFO  ShardingSphere-SQL - Actual SQL: ds0 ::: SELECT id,teacherId,name FROM student WHERE id=?  ::: [706168069961023488]</span><br><span class="line">INFO  ShardingSphere-SQL - Actual SQL: ds1 ::: SELECT id,teacherId,name FROM student WHERE id=?  ::: [706168069961023488]</span><br></pre></td></tr></table></figure>

<p>可以看到,一条sql自动分成了两个真实的sql,没错,该框架,就是通过改写sql实现了分库分表,这是它的基本思路</p>
<h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>虽然ShardingSphere支持很多功能,但是最重要的功能就是数据分片.</p>
<p><strong>尽量透明化分库分表所带来的影响，让使用方尽量像使用一个数据库一样使用水平分片之后的数据库集群，是 Apache ShardingSphere 数据分片模块的主要设计目标。</strong></p>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><h5 id="逻辑表"><a href="#逻辑表" class="headerlink" title="逻辑表"></a>逻辑表</h5><p>相同结构的水平拆分数据库（表）的逻辑名称，是 SQL 中表的逻辑标识。 例：订单数据根据主键尾数拆分为 10 张表，分别是 t_order_0 到 t_order_9，他们的逻辑表名为 t_order。</p>
<h5 id="真实表"><a href="#真实表" class="headerlink" title="真实表"></a>真实表</h5><p>在水平拆分的数据库中真实存在的物理表。 即上个示例中的 t_order_0 到 t_order_9。</p>
<h5 id="绑定表"><a href="#绑定表" class="headerlink" title="绑定表"></a>绑定表</h5><p>指分片规则一致的主表和子表。 使用绑定表进行多表关联查询时，必须使用分片键进行关联，否则会出现笛卡尔积关联或跨库关联，从而影响查询效率。</p>
<h5 id="广播表"><a href="#广播表" class="headerlink" title="广播表"></a>广播表</h5><p>指所有的分片数据源中都存在的表，表结构及其数据在每个数据库中均完全一致。 适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。</p>
<h5 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h5><p>指所有的分片数据源中仅唯一存在的表。 适用于数据量不大且无需分片的表。</p>
<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>分片算法</p>
<ol>
<li>自动化分片算法</li>
<li>自定义分片算法</li>
</ol>
<p>分片策略<br>包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。 真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。</p>
<p>强制分片路由<br>对于分片字段并非由 SQL 而是其他外置条件决定的场景，可使用 SQL Hint 注入分片值。</p>
<h4 id="内置分片算法"><a href="#内置分片算法" class="headerlink" title="内置分片算法"></a>内置分片算法</h4><p>其实分片,就是尽量把数据均匀的分散开来,越平均越好</p>
<h5 id="自动分片算法"><a href="#自动分片算法" class="headerlink" title="自动分片算法"></a>自动分片算法</h5><ol>
<li>取模分片算法 针对整形</li>
<li>哈希取模分片算法 针对字符串类型</li>
<li>基于分片容量的范围分片算法 需要针对一个个真实表设置,比较麻烦,暂时没有想到场景</li>
<li>基于分片边界的范围分片算法 没看懂</li>
<li>自动时间段分片算法 特别适合对时间敏感的业务,比如当前月的数据经常使用,但是除了当月的以前的数据,基本就是存档,然后所有的查询都加上分片,相当于数据自动归档了,非常方便</li>
</ol>
<h5 id="标准分片算法"><a href="#标准分片算法" class="headerlink" title="标准分片算法"></a>标准分片算法</h5><ol>
<li>行表达式分片算法 如t_user_$-&gt;{u_id % 8}</li>
<li>时间范围分片算法 适合时间敏感的业务</li>
</ol>
<h5 id="复合分片算法"><a href="#复合分片算法" class="headerlink" title="复合分片算法"></a>复合分片算法</h5><p>多个列一起分片,功能强大,但是尽量少用,越简单满足业务一般越好</p>
<h5 id="Hint-分片算法"><a href="#Hint-分片算法" class="headerlink" title="Hint 分片算法"></a>Hint 分片算法</h5><p>使用行表达式进行分片</p>
<h5 id="自定义类分片算法"><a href="#自定义类分片算法" class="headerlink" title="自定义类分片算法"></a>自定义类分片算法</h5><p>自己写代码定义,然后配置</p>
<h3 id="较佳实践"><a href="#较佳实践" class="headerlink" title="较佳实践"></a>较佳实践</h3><h4 id="垂直还是水平"><a href="#垂直还是水平" class="headerlink" title="垂直还是水平"></a>垂直还是水平</h4><p>shardingsphere,功能非常强大,垂直和水平直接都支持,而且还非常方便,所以,我们使用的时候,直接使用即可,<br>比如,需要两个库,一个库放系统数据,比如用户表,权限表之类的,一个库放业务数据,比如订单,商品等等,就可以垂直分库,<br>如果一个表比较大,那么水平拆分成多个小表即可</p>
<h4 id="分库还是分表"><a href="#分库还是分表" class="headerlink" title="分库还是分表"></a>分库还是分表</h4><p>分库<br>数据库应用应该是io和计算都很密集,一方面,需要io查找数据,另一方面需要在内存中计算数据,所以,相对来说,很吃cpu,<br>所以,一般,数据库应用本身,再高并发场景下,都是一台机器部署一个数据库,所以,分库可以吃多个机器的资源,可以更好的支持并发<br>分表<br>因为数据库本身的设计原因和机器资源的原因,单表数据量大到一定程度以后,性能会不断下降,数据量越大,越不可忍受,所以,<br>出现了分表的需求,分表就是在资源不变的情况下,通过减少单表的数据量,增加数据库的查询性能<br>总结<br>如果你的并发要求不是很高,而且你的业务对时间敏感,老的数据放到老的表,不影响新的数据查询,那么分表就是很好的选择,<br>如果你的并发要求很高,分表以后,一个机器的计算资源还是不能满足你的业务,那么就妥妥的需要分库,所以,分库比分表更能提高并发,但是<br>分表也能更好的发挥单机的价值,不是冲突的,而是相辅相成的,不是意味着,我分库了,就不需要分表了,而是分库以后,也需要分表,相辅相成</p>
<h4 id="数据分片的选择"><a href="#数据分片的选择" class="headerlink" title="数据分片的选择"></a>数据分片的选择</h4><p>分片选择原则</p>
<ol>
<li>简单性,能一个列分片,就一个列分片,用最简单的方式满足业务,差不多就是最好的方式</li>
<li>内置性,尽量使用shardingsphere内置的算法,或许有优化吧,不过,这得看代码了</li>
</ol>
<p>对于大多应用来说,使用时间分片都是一个非常不错的选择,大多数系统只关心最近的数据,以往的数据只是存档使用,这样的话,非常适合时间分片,<br>如果一个库不够的话,数字类型就用取模分片分库,字符串类型就用hash分片分库</p>
<h4 id="分页优化"><a href="#分页优化" class="headerlink" title="分页优化"></a>分页优化</h4><p>众所周知,数据量大的时候分页,性能非常差,主要原因就是查1一亿条,排序完,最后只用10条,显然很慢,所以说,不能把那一亿条查出来,<br>理想的方案是记录上次的id,然后只查10条数据,如下所示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100000</span> LIMIT <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>shardingSphere最重要的功能是数据分片,数据分片最重要的功能是分片算法,只要这两个吃透,差不多shardingSphere你就掌握了60%了</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>shardingsphere</tag>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>skyWalking简介</title>
    <url>/2021/09/01/skyWalking%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="skyWalking简介"><a href="#skyWalking简介" class="headerlink" title="skyWalking简介"></a>skyWalking简介</h1><h3 id="skyWalking-是什么"><a href="#skyWalking-是什么" class="headerlink" title="skyWalking 是什么"></a>skyWalking 是什么</h3><p><a href="http://skywalking.apache.org/" title="skywalking官网">FROM http://skywalking.apache.org/</a><br><strong>分布式系统的应用程序性能监视工具,专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计.</strong><br><strong>提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案.</strong></p>
<h3 id="项目历史"><a href="#项目历史" class="headerlink" title="项目历史"></a>项目历史</h3><p>最早出现于2016年,然后2017-12-08年进入apache孵化,大约2019-01-29时候,差不多孵化结束了,然后开始产品,此时已经是6.0.0-GA版本</p>
<p>下面一张图可以看出,差不多,主要就一个contributors,占据了1&#x2F;3之一的提交,可能50%的工作都是他完成的,从16年到现在,已经5年了 </p>
<img src="/2021/09/01/skyWalking%E7%AE%80%E4%BB%8B/contributors.png" class="" title="contributors历史">
<p>然后,skyWalking一直因为优秀的设计,不断受到关注,star历史,可以看出来是平稳上升</p>
<img src="/2021/09/01/skyWalking%E7%AE%80%E4%BB%8B/sky-walking-start-history.png" class="" title="start历史">

<h3 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h3><p>skyWalking 有哪些功能？</p>
<p><a href="http://skywalking.apache.org/" title="skywalking官网">FROM http://skywalking.apache.org/</a></p>
<ul>
<li>多种监控手段.可以通过语言探针和 service mesh 获得监控是数据.</li>
<li>多个语言自动探针.包括 Java,.NET Core 和 Node.JS.</li>
<li>轻量高效.无需大数据平台,和大量的服务器资源.</li>
<li>支持告警.</li>
<li>多种监控手段.可以通过语言探针和 service mesh 获得监控是数据.</li>
<li>优秀的可视化解决方案.</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><img src="/2021/09/01/skyWalking%E7%AE%80%E4%BB%8B/architecture.jpg" class="" title="整体架构">

<ul>
<li>Receiver Cluster :负责从应用中,收集链路信息,发送给 Aggregator Cluster 服务器.</li>
<li>Aggregator Cluster :负责接收 Agent 发送的 Tracing 数据信息,然后进行分析(Analysis Core),存储到外部存储器( Storage ),最终提供查询( Query )功能.</li>
<li>Storage Options:Tracing 数据存储.目前支持 ES、MySQL、Sharding Sphere、TiDB、H2 多种存储器.主要推荐分布式存储并且查询性能极好,比如ES.</li>
<li>Alarm Notification,Exporter:负责展示信息和提供预警的功能.</li>
</ul>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="单机环境"><a href="#单机环境" class="headerlink" title="单机环境"></a>单机环境</h3><img src="/2021/09/01/skyWalking%E7%AE%80%E4%BB%8B/deploy.jpg" class="" title="部署">

<ol>
<li>搭建一个 Elasticsearch 服务.</li>
<li>下载 SkyWalking 软件包.</li>
<li>搭建一个 SkyWalking OAP 服务.</li>
<li>启动一个 Spring Boot 应用,并配置 SkyWalking Agent.</li>
<li>搭建一个 SkyWalking UI 服务.</li>
</ol>
<h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol>
<li>下载skyWalking包</li>
<li>启动oap</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh bin/oapService.sh</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动web UI</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh bin/webappService.sh</span><br></pre></td></tr></table></figure>

<p>默认地址<code>http://127.0.0.1:8080</code></p>
<ol start="4">
<li>应用集成</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-javaagent:/home/ss/opt/apache-skywalking-apm-bin-es7/agent/skywalking-agent.jar</span><br></pre></td></tr></table></figure>

<h3 id="功能和概念简介"><a href="#功能和概念简介" class="headerlink" title="功能和概念简介"></a>功能和概念简介</h3><ol>
<li>服务(Service):表示对请求提供相同行为的一系列或一组工作负载.agent的使用对象,可以通过<code>SW_AGENT_NAME</code>定义</li>
<li>服务实例(Service Instance):上述的一组工作负载中的每一个工作负载称为一个实例.相同服务的多个实例</li>
<li>端点(Endpoint):对于特定服务所接收的请求路径, 如HTTP的URI路径和gRPC服务的类名+方法签名.在spring中,对应就是一个api.</li>
</ol>
<img src="/2021/09/01/skyWalking%E7%AE%80%E4%BB%8B/dashboard.png" class="" title="仪表盘">
<img src="/2021/09/01/skyWalking%E7%AE%80%E4%BB%8B/topology.png" class="" title="拓扑图">
<img src="/2021/09/01/skyWalking%E7%AE%80%E4%BB%8B/trace.png" class="" title="跟踪">

<h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3><p>一般在生产环境中,需要使用集群部署来保证高可用,但是如果要求不高的话,单机也可以,即使skyWalking挂了也不会影响应用的正常运行</p>
<ol>
<li>搭建es集群</li>
<li>搭建一个注册中心,目前 SkyWalking 支持 Zookeeper、Kubernetes、Consul、Nacos 作为注册中心</li>
<li>搭建OAP服务集群,并注册到服务中心上</li>
<li>监控的spring boot应用,需要配置skyWalking agent,并且设置<code>SW_AGENT_COLLECTOR_BACKEND_SERVICES</code>地址数组,就是OAP服务的地址数组</li>
<li>还可以搭建skyWalking UI服务的集群,使用nginx进行负责均衡</li>
</ol>
<p>总体可以看到,任何一个环节都是集群,来满足高可用</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>skyWalking</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>skyWalking-javaAgent解析</title>
    <url>/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="skyWalking-java如何收集数据"><a href="#skyWalking-java如何收集数据" class="headerlink" title="skyWalking java如何收集数据"></a>skyWalking java如何收集数据</h1><p>skyWalking被java程序使用的时候,需要添加-javaagent参数,javaagent的作用其实很多,但是简单来说,就是启动前替换java类</p>
<p><strong>代码引用基于<code>v8.7.0</code>版本</strong></p>
<h3 id="instrument"><a href="#instrument" class="headerlink" title="instrument"></a>instrument</h3><p>jdk5引入了<code>java.lang.instrument</code>,该包提供了一个Java编程API,可以用来开发增强Java应用程序的工具,例如监视它们或收集性能信息. 使用<code>instrumentation</code>,开发者可以构建一个独立于应用程序的代理程序（Agent,用来监测和协助运行在 JVM 上的程序,甚至能够替换和修改某些类的定义.有了这样的功能,开发者就可以实现更为灵活的运行时虚拟机监控和Java类操作了,这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式,使得开发者无需对 JDK 做任何升级和改动,就可以实现某些 AOP 的功能了.</p>
<p><strong>这里的AOP是JVM级别的AOP,已经和业务无关,和业务有关的AOP就不能用这个类型,比如事务,缓存,因为这里的AOP完全与业务解耦了,所以,基本上,<code>instrumentation</code>一般只能用来监控</strong></p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>其实监控,就是方法执行前,执行后做一些动作.平常我们其实也经常用AOP,比如日志,缓存,事务等等,所以说,skyWalking收集数据的思路就是使用AOP.AOP的实现就是创建代理类,也就是修改类,做处理.</p>
<h2 id="自己动手写一个javaagent"><a href="#自己动手写一个javaagent" class="headerlink" title="自己动手写一个javaagent"></a>自己动手写一个javaagent</h2><ol>
<li>编写带有特定方法的类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>打包成jar,并且添加manifest属性<code>Premain-Class: pers.apricot.MyAgent</code></li>
<li>应用添加<code>-javaagent:agent.jar=$&#123;agentArgs&#125;</code>启动,就可以看到效果</li>
</ol>
<p>我这里写了一个简单的不带aop的agent</p>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/myagent.png" class="" title="一个简单的javaagent">
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/instrumentation.png" class="" title="instrumentation">
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/class_file_transformer.png" class="" title="classFileTransformer">

<h2 id="org-apache-agent-SkyWalkingAgent-解析"><a href="#org-apache-agent-SkyWalkingAgent-解析" class="headerlink" title="org.apache.**.agent.SkyWalkingAgent 解析"></a>org.apache.**.agent.SkyWalkingAgent 解析</h2><p>这里可以看到其明显使用了我们刚才介绍的<code>instrument</code>,并且这里有个新的框架<code>bytebuddy</code>.</p>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/sky_walking-agent.png" class="" title="SkyWalkingAgent">

<h3 id="bytebuddy简介"><a href="#bytebuddy简介" class="headerlink" title="bytebuddy简介"></a><code>bytebuddy</code>简介</h3><p>动态修改类有两派,一派是java source类型,就是用string新建类和修改类,这类的典型代表是javaassist,还有一类就是非常硬核的修改bytecode,如asm,前者比较简单,后者需要掌握的就比较多.</p>
<p><code>bytebuddy</code>属于java source派,可以动态的生成java字节码文件,比起我们自己进行字节码文件的生成,它屏蔽了底层细节,提供一套统一易上手的Api,简化了字节码增强的学习难度,而且<code>bytebuddy</code>针对javaagent做了封装,<br>我们可以非常简单的使用它的api挑选我们自己想要增强的类,来增强<br><a href="https://blog.csdn.net/m0_37556444/article/details/106695202">ByteBuddy使用入坑</a></p>
<h2 id="skyWalking自定义插件"><a href="#skyWalking自定义插件" class="headerlink" title="skyWalking自定义插件"></a>skyWalking自定义插件</h2><p><code>skyWalking</code>虽然使用<code>byteBuddy</code>但是,自己定义了一套插件机制,而不是直接使用字节码增加</p>
<p><code>skyWalking</code>自定义了一套插件体系,并且<code>skyWalking</code>官方维护了很多常用的插件,开发完插件以后,放到<code>plugins</code>目录即可生效</p>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/sky-walking-plugin.png" class="" title="plugins">
<p>这里可以看到同一个插件,因为版本不同,也需要不同plugin,可见,插件的开发也是一项繁重的体力活</p>
<p><a href="https://skyapm.github.io/document-cn-translation-of-skywalking/zh/6.2.0/guides/Java-Plugin-Development-Guide.html">插件开发指南</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>追踪的基本方法是拦截Java方法,使用字节码操作技术和AOP概念.SkyWalking包装了字节码操作技术,并追踪上下文的传播.所以你只需要定义拦截点(换句话说就是Spring的切面).</p>
<h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><p><code>skywalking</code>提供了两类通用的定义去拦截构造方法,实例方法和静态方法</p>
<ol>
<li><code>ClassInstanceMethodsEnhancePluginDefine</code>定义了<code>Contructor</code>和<code>instance method</code>实例方法拦截点</li>
<li><code>ClassStaticMethodsEnhancePluginDefine</code>定义了<code>class method</code>拦截点</li>
<li>继承<code>ClassEnhancePluginDefine</code>去设置所有的拦截点,不常用</li>
</ol>
<h3 id="匹配目标类"><a href="#匹配目标类" class="headerlink" title="匹配目标类"></a>匹配目标类</h3><p>定义<code>ClassInstanceMethodsEnhancePluginDefine</code>的子类,重写<code>enhanceClass</code>去匹配目标类.</p>
<p><code>ClassMatch</code>ClassMatch表示如何去匹配目标类,这里有四种方法</p>
<ol>
<li>byName, 通过类的全限定名(Fully Qualified Class Name, 即 包名 + . + 类名).</li>
<li>byClassAnnotationMatch, 根据目标类是否存在某些注解.</li>
<li>byMethodAnnotationMatch, 根据目标类的方法是否存在某些注解.</li>
<li>byHierarchyMatch, 根据目标类的父类或接口</li>
</ol>
<p><strong>注意事项:</strong></p>
<ol>
<li>禁止使用 <em>.class.getName() 去获取类名, 建议你使用文本字符串, 这是为了避免 ClassLoader 的问题.by</em>AnnotationMatch 不支持从父类继承来的注解.</li>
<li>除非确实必要, 否则不建议使用 byHierarchyMatch, 因为使用它可能会触发拦截许多预期之外的方法, 会导致性能问题和不稳定.</li>
</ol>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/driver-instrumentation.png" class="" title="DriverInstrumentation">

<h3 id="定义方法拦截"><a href="#定义方法拦截" class="headerlink" title="定义方法拦截"></a>定义方法拦截</h3><p>重新<code>getInstanceMethodsInterceptPoints</code>方法</p>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/get_instance_methods_intercept_points.png" class="" title="getInstanceMethodsInterceptPoints">

<ol>
<li>重新方法</li>
<li>定义拦截方法的几种逻辑</li>
<li>方法匹配</li>
<li>放回方法拦截器的全类名,这个<code>ElementMatcher</code>是<code>byteBuddy</code>的内容,所以,<code>skyWalking</code>这块的实现直接套用了<code>byteBuddy</code>的东西,省了一些代码</li>
<li>是否覆盖参数,如果你需要在拦截器中更改引用的参数,就需要返回<code>true</code>,修改<code>InstanceMethodsAroundInterceptor</code>的<code>allArguments</code>才起效</li>
</ol>
<h3 id="skywalking-plugin-def-添加定义"><a href="#skywalking-plugin-def-添加定义" class="headerlink" title="skywalking-plugin.def 添加定义"></a>skywalking-plugin.def 添加定义</h3><p>key是语义化的名字即可,然后后面是<code>Instrumentation</code>的全限定类名,也就是定义拦截的类,拦截的方法,拦截的逻辑,这三个要素的类</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">key=com.any.SomeClass</span><br></pre></td></tr></table></figure>

<h3 id="实现拦截器"><a href="#实现拦截器" class="headerlink" title="实现拦截器"></a>实现拦截器</h3><img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/instance_methods_around_interceptor.png" class="" title="InstanceMethodsAroundInterceptor">

<ol>
<li>接口名称</li>
<li>方法执行前,获取该对象,该方法,传的参数,参数类型,方法拦截结果</li>
<li>方法执行后,返回的结果,这里可以返回自定义的结果,也s就是返回代理对象</li>
</ol>
<h2 id="skyWalking-jdbc-插件解析"><a href="#skyWalking-jdbc-插件解析" class="headerlink" title="skyWalking jdbc 插件解析"></a>skyWalking jdbc 插件解析</h2><img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/PreparedStatementInstrumentation.png" class="" title="PreparedStatementInstrumentation">

<ol>
<li>定义拦截的类</li>
<li>定义拦截的方法</li>
</ol>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/PreparedStatementExecuteMethodsInterceptor.png" class="" title="PreparedStatementExecuteMethodsInterceptor">

<ol>
<li>定义拦截的逻辑,创建span</li>
<li>设定cmponent</li>
<li>设定layer</li>
</ol>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/skywalking-plugin.png" class="" title="def-plugin">

<ol>
<li>添加定义</li>
</ol>
<h2 id="自定义开发组件"><a href="#自定义开发组件" class="headerlink" title="自定义开发组件"></a>自定义开发组件</h2><p>在项目中,我使用了<code>RestTemplate</code>和外部的接口交互,获取数据,假定我想记录我发送了多少次请求,每次请求的内容是什么,返回的内容是什么,以这个作为需求来<br>开发一个<code>skyWalking</code>的插件</p>
<h3 id="拦截的类和方法"><a href="#拦截的类和方法" class="headerlink" title="拦截的类和方法"></a>拦截的类和方法</h3><img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/postForEntity.png" class="" title="postForEntity">

<p>我主要就用了这一个方法,名字是<code>postForEntity</code>,有三个重载的方法,但是我只拦截这一个</p>
<h3 id="Instrumentation编码"><a href="#Instrumentation编码" class="headerlink" title="Instrumentation编码"></a>Instrumentation编码</h3><img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/RestTemplateInstrumentation.png" class="" title="RestTemplateInstrumentation">

<ol>
<li>拦截的类名</li>
<li>拦截的方法,需要按照需要精确定义</li>
<li>拦截器</li>
</ol>
<h3 id="Interceptor-编码"><a href="#Interceptor-编码" class="headerlink" title="Interceptor 编码"></a>Interceptor 编码</h3><img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/RestTemplateInterceptor.png" class="" title="RestTemplateInterceptor">

<p>我根据需求,根据入参和返回的参数,获取我需要数据,完成了http发送请求请求参数和返回数据的获取</p>
<ol>
<li>创建<code>ContextCarrier</code></li>
<li>定义<code>component</code></li>
<li>定义<code>layer</code></li>
<li>设置<code>params</code></li>
<li>设置<code>body</code></li>
</ol>
<h3 id="skywalking-plugin-def"><a href="#skywalking-plugin-def" class="headerlink" title="skywalking-plugin.def"></a>skywalking-plugin.def</h3><p>根据规范设置Instrumentation</p>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/skywalking-plugin_def.png" class="" title="skywalking-plugin.def">

<h3 id="查询效果"><a href="#查询效果" class="headerlink" title="查询效果"></a>查询效果</h3><ol>
<li>我首先打包这个jar</li>
<li>然后放到<code>plugins</code>目录</li>
<li>依次启动服务,然后触发这些记录</li>
</ol>
<p>可以看到多加了一条我自己的记录</p>
<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/trace_tree.png" class="" title="trace">

<img src="/2021/09/06/skyWalking-javaAgent%E8%A7%A3%E6%9E%90/span_info.png" class="" title="span">

<ol>
<li>component被正确设置</li>
<li>peer也被正确设置</li>
<li>url被正确设置</li>
<li>params都被正常设置</li>
<li>body被正常设置</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>skyWalking</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>skywalking-agent数据收集源码讲解</title>
    <url>/2021/09/13/skywalking-agent%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="skywalking-agent数据收集源码讲解"><a href="#skywalking-agent数据收集源码讲解" class="headerlink" title="skywalking-agent数据收集源码讲解"></a>skywalking-agent数据收集源码讲解</h1><p>从源码的角度来探讨,skywalking到底如何收集发送数据</p>
<p><strong>代码引用基于<code>v8.7.0</code>版本</strong></p>
<h3 id="GRPCChannelListener-grpc状态监控"><a href="#GRPCChannelListener-grpc状态监控" class="headerlink" title="GRPCChannelListener grpc状态监控"></a>GRPCChannelListener grpc状态监控</h3><p>skywalking通过grpc发送数据,所以,用grpc发送数据的,都需要实现<code>GRPCChannelListener</code>来查看grpc的连接状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GRPCChannelListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">statusChanged</span><span class="params">(GRPCChannelStatus status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/13/skywalking-agent%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/GRPCChannelListener-hierachy.png" class="" title="GRPCChannelListener-继承体系">
<p>有很多类型的数据需要发送,但是常见的三种</p>
<ol>
<li>jvm的信息发送</li>
<li>服务管理信息发送</li>
<li>span信息,也就是plugin收集的监控发送</li>
</ol>
<h3 id="TraceSegmentServiceClient-发送监控数据"><a href="#TraceSegmentServiceClient-发送监控数据" class="headerlink" title="TraceSegmentServiceClient 发送监控数据"></a>TraceSegmentServiceClient 发送监控数据</h3><h4 id="TraceSegmentServiceClient"><a href="#TraceSegmentServiceClient" class="headerlink" title="TraceSegmentServiceClient"></a>TraceSegmentServiceClient</h4><p>TraceSegmentServiceClient负责监控数据的发送,同时实现了四个接口,分别时<code>BootService</code>,<code>IConsumer</code>,<code>TracingContextListener</code>,<code>GRPCChannelListener</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DefaultImplementor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraceSegmentServiceClient</span> <span class="keyword">implements</span> <span class="title class_">BootService</span>, IConsumer&lt;TraceSegment&gt;, TracingContextListener, GRPCChannelListener &#123;</span><br><span class="line">    <span class="comment">// ... omit </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BootService</code>使用java spi机制初始化,接口里面的主要内容就是生命周期,类似spring bean的生命周期,<code>ServiceManager</code>负责初始化所有的<code>BootService</code>,<br>在<code>SkyWalkingAgent</code>启动的时候完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &lt;code&gt;BootService&lt;/code&gt; is an interface to all remote, which need to boot when plugin mechanism begins to work.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #boot()&#125; will be called when &lt;code&gt;BootService&lt;/code&gt; start up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BootService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boot</span><span class="params">()</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> BootService&#125;s with higher priorities will be started earlier, and shut down later than those &#123;<span class="doctag">@code</span> BootService&#125;s with lower priorities.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the priority of this &#123;<span class="doctag">@code</span> BootService&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IConsumer</code>负责数据的发送,主要由<code>DataCarrier</code>使用,关键方法consume就是使用生产者消费者模式来消费数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IConsumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(List&lt;T&gt; data)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(List&lt;T&gt; data, Throwable t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onExit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notify the implementation, if there is nothing fetched from the queue. This could be used as a timer to trigger</span></span><br><span class="line"><span class="comment">     * reaction if the queue has no element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">nothingToConsume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TracingContextListener</code>通知一次监控完成,开始生成消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TracingContextListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterFinished</span><span class="params">(TraceSegment traceSegment)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义消息发送"><a href="#自定义消息发送" class="headerlink" title="自定义消息发送"></a>自定义消息发送</h3><p><code>LocalLogTraceSegmentServiceClient</code>写到本地文件中,记得添加spi文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OverrideImplementor(TraceSegmentServiceClient.class)</span><span class="comment">//替换原有的TraceSegmentServiceClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalLogTraceSegmentServiceClient</span> <span class="keyword">implements</span> <span class="title class_">BootService</span>, IConsumer&lt;TraceSegment&gt;, TracingContextListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> DataCarrier&lt;TraceSegment&gt; carrier;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">boot</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//创建dataCarrier</span></span><br><span class="line">        carrier = <span class="keyword">new</span> <span class="title class_">DataCarrier</span>&lt;&gt;(CHANNEL_SIZE, BUFFER_SIZE, BufferStrategy.IF_POSSIBLE);</span><br><span class="line">        carrier.consume(<span class="built_in">this</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//添加到TracingContext监听</span></span><br><span class="line">        TracingContext.ListenerManager.add(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        TracingContext.ListenerManager.remove(<span class="built_in">this</span>);</span><br><span class="line">        carrier.shutdownConsumers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(List&lt;TraceSegment&gt; data)</span> &#123;</span><br><span class="line">        <span class="comment">//假设写入本地文件</span></span><br><span class="line">        System.out.print(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(List&lt;TraceSegment&gt; data, Throwable t)</span> &#123;</span><br><span class="line">        System.out.print(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onExit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterFinished</span><span class="params">(TraceSegment traceSegment)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (traceSegment.isIgnore()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生产数据</span></span><br><span class="line">        carrier.produce(traceSegment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>skyWalking</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>skywalking-oap数据接收</title>
    <url>/2021/09/13/skywalking-oap%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6/</url>
    <content><![CDATA[<h1 id="skywalking-oap数据接收"><a href="#skywalking-oap数据接收" class="headerlink" title="skywalking-oap数据接收"></a>skywalking-oap数据接收</h1><p><strong>代码引用基于<code>v8.7.0</code>版本</strong></p>
<h3 id="从GRPCHandler入手-查看skywalking的收集体系"><a href="#从GRPCHandler入手-查看skywalking的收集体系" class="headerlink" title="从GRPCHandler入手,查看skywalking的收集体系"></a>从<code>GRPCHandler</code>入手,查看skywalking的收集体系</h3><p><code>GRPCHandler</code>只是一个标识接口,没有具体的含义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GRPCHandler</span> <span class="keyword">extends</span> <span class="title class_">ServerHandler</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/13/skywalking-oap%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6/GRPCHandler-hierarchy.png" class="" title="GRPCHandler-继承体系">
<p>可以看到里面有很多的接收器,分别处理不同的发送</p>
<ol>
<li>监控数据的接收器</li>
</ol>
<h3 id="TraceSegmentReportServiceHandler"><a href="#TraceSegmentReportServiceHandler" class="headerlink" title="TraceSegmentReportServiceHandler"></a><code>TraceSegmentReportServiceHandler</code></h3><p><code>TraceSegmentReportServiceHandler</code>是一个grpc的类,继承了grpc相关的类,<code>collect</code>里面负责解析<code>SegmentObject</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StreamObserver&lt;SegmentObject&gt; <span class="title function_">collect</span><span class="params">(StreamObserver&lt;Commands&gt; responseObserver)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamObserver</span>&lt;SegmentObject&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(SegmentObject segment)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;received segment in streaming&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                HistogramMetrics.<span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> histogram.createTimer();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//segmentParserService解析SegmentObject</span></span><br><span class="line">                    segmentParserService.send(segment);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    errorCounter.inc();</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    timer.finish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                log.error(throwable.getMessage(), throwable);</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">                responseObserver.onNext(Commands.newBuilder().build());</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SegmentParserServiceImpl"><a href="#SegmentParserServiceImpl" class="headerlink" title="SegmentParserServiceImpl"></a><code>SegmentParserServiceImpl</code></h3><p>负责<code>SegmentObject</code>的解析,但主要使用了委托模式,真正执行逻辑的是<code>TraceAnalyzer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentParserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ISegmentParserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ModuleManager moduleManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnalyzerModuleConfig config;</span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> SegmentParserListenerManager listenerManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(SegmentObject segment)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TraceAnalyzer</span> <span class="variable">traceAnalyzer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraceAnalyzer</span>(moduleManager, listenerManager, config);</span><br><span class="line">        <span class="comment">// 委托给TraceAnalyzer执行</span></span><br><span class="line">        traceAnalyzer.doAnalysis(segment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="traceAnalyzer"><a href="#traceAnalyzer" class="headerlink" title="traceAnalyzer"></a><code>traceAnalyzer</code></h3><p>分析<code>Span</code>的类型,主要有三种,然后分别构建到不同的队列里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAnalysis</span><span class="params">(SegmentObject segmentObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (segmentObject.getSpansList().size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createSpanListeners();</span><br><span class="line"></span><br><span class="line">        notifySegmentListener(segmentObject);</span><br><span class="line"></span><br><span class="line">        segmentObject.getSpansList().forEach(spanObject -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (spanObject.getSpanId() == <span class="number">0</span>) &#123;</span><br><span class="line">                notifyFirstListener(spanObject, segmentObject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (SpanType.Exit.equals(spanObject.getSpanType())) &#123;</span><br><span class="line">                notifyExitListener(spanObject, segmentObject);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SpanType.Entry.equals(spanObject.getSpanType())) &#123;</span><br><span class="line">                notifyEntryListener(spanObject, segmentObject);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SpanType.Local.equals(spanObject.getSpanType())) &#123;</span><br><span class="line">                notifyLocalListener(spanObject, segmentObject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;span type value was unexpected, span type name: &#123;&#125;&quot;</span>, spanObject.getSpanType()</span><br><span class="line">                                                                                          .name());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        notifyListenerToBuild();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyListenerToBuild</span><span class="params">()</span> &#123;</span><br><span class="line">    analysisListeners.forEach(AnalysisListener::build);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MultiScopesAnalysisListener"><a href="#MultiScopesAnalysisListener" class="headerlink" title="MultiScopesAnalysisListener"></a>MultiScopesAnalysisListener</h3><p>从<code>AnalysisListener::build</code>顺藤摸瓜,就找到了<code>MultiScopesAnalysisListener</code>,<code>MultiScopesAnalysisListener</code>的作用就是把<code>Span</code>分类,通过不同的<code>sourceReceiver</code>接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        entrySourceBuilders.forEach(entrySourceBuilder -&gt; &#123;</span><br><span class="line">            entrySourceBuilder.prepare();</span><br><span class="line">            sourceReceiver.receive(entrySourceBuilder.toAll());</span><br><span class="line">            sourceReceiver.receive(entrySourceBuilder.toService());</span><br><span class="line">            sourceReceiver.receive(entrySourceBuilder.toServiceInstance());</span><br><span class="line">            sourceReceiver.receive(entrySourceBuilder.toEndpoint());</span><br><span class="line">            sourceReceiver.receive(entrySourceBuilder.toServiceRelation());</span><br><span class="line">            sourceReceiver.receive(entrySourceBuilder.toServiceInstanceRelation());</span><br><span class="line">            <span class="type">EndpointRelation</span> <span class="variable">endpointRelation</span> <span class="operator">=</span> entrySourceBuilder.toEndpointRelation();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Parent endpoint could be none, because in SkyWalking Cross Process Propagation Headers Protocol v2,</span></span><br><span class="line"><span class="comment">             * endpoint in ref could be empty, based on that, endpoint relation maybe can&#x27;t be established.</span></span><br><span class="line"><span class="comment">             * So, I am making this source as optional.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Also, since 6.6.0, source endpoint could be none, if this trace begins by an internal task(local span or exit span), such as Timer,</span></span><br><span class="line"><span class="comment">             * rather than, normally begin as an entry span, like a RPC server side.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (endpointRelation != <span class="literal">null</span>) &#123;</span><br><span class="line">                sourceReceiver.receive(endpointRelation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        exitSourceBuilders.forEach(exitSourceBuilder -&gt; &#123;</span><br><span class="line">            exitSourceBuilder.prepare();</span><br><span class="line">            sourceReceiver.receive(exitSourceBuilder.toServiceRelation());</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Some of the agent can not have the upstream real network address, such as https://github.com/apache/skywalking-nginx-lua.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServiceInstanceRelation</span> <span class="variable">serviceInstanceRelation</span> <span class="operator">=</span> exitSourceBuilder.toServiceInstanceRelation();</span><br><span class="line">            <span class="keyword">if</span> (serviceInstanceRelation != <span class="literal">null</span>) &#123;</span><br><span class="line">                sourceReceiver.receive(serviceInstanceRelation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (RequestType.DATABASE.equals(exitSourceBuilder.getType())) &#123;</span><br><span class="line">                sourceReceiver.receive(exitSourceBuilder.toServiceMeta());</span><br><span class="line">                sourceReceiver.receive(exitSourceBuilder.toDatabaseAccess());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        dbSlowStatementBuilders.forEach(dbSlowStatBuilder -&gt; &#123;</span><br><span class="line">            dbSlowStatBuilder.prepare();</span><br><span class="line">            sourceReceiver.receive(dbSlowStatBuilder.toDatabaseSlowStatement());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        logicEndpointBuilders.forEach(logicEndpointBuilder -&gt; &#123;</span><br><span class="line">            logicEndpointBuilder.prepare();</span><br><span class="line">            sourceReceiver.receive(logicEndpointBuilder.toEndpoint());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SourceReceiver"><a href="#SourceReceiver" class="headerlink" title="SourceReceiver"></a><code>SourceReceiver</code></h3><p>负责监控的收集和转发,主要实现是<code>SourceReceiverImpl</code>,里面有转发的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SourceReceiver</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(ISource source)</span>;</span><br><span class="line"></span><br><span class="line">    DispatcherDetectorListener <span class="title function_">getDispatcherDetectorListener</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SourceReceiverImpl</span> <span class="keyword">implements</span> <span class="title class_">SourceReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DispatcherManager dispatcherManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SourceReceiverImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dispatcherManager = <span class="keyword">new</span> <span class="title class_">DispatcherManager</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(ISource source)</span> &#123;</span><br><span class="line">    <span class="comment">//在这里转发</span></span><br><span class="line">        dispatcherManager.forward(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherDetectorListener <span class="title function_">getDispatcherDetectorListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDispatcherManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        dispatcherManager.scan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DispatcherManager"><a href="#DispatcherManager" class="headerlink" title="DispatcherManager"></a><code>DispatcherManager</code></h3><p>负责<code>SourceDispatcher</code>的转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, List&lt;SourceDispatcher&gt;&gt; dispatcherMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DispatcherManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dispatcherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">(ISource source)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;SourceDispatcher&gt; dispatchers = dispatcherMap.get(source.scope());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dispatcher is only generated by oal script analysis result.</span></span><br><span class="line"><span class="comment">     * So these will/could be possible, the given source doesn&#x27;t have the dispatcher,</span></span><br><span class="line"><span class="comment">     * when the receiver is open, and oal script doesn&#x27;t ask for analysis.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dispatchers != <span class="literal">null</span>) &#123;</span><br><span class="line">        source.prepare();</span><br><span class="line">        <span class="keyword">for</span> (SourceDispatcher dispatcher : dispatchers) &#123;</span><br><span class="line">        <span class="comment">//就是在这里转发</span></span><br><span class="line">            dispatcher.dispatch(source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SourceDispatcher"><a href="#SourceDispatcher" class="headerlink" title="SourceDispatcher"></a><code>SourceDispatcher</code></h3><p>有非常多得实现类,具体转发到那里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SourceDispatcher</span>&lt;SOURCE <span class="keyword">extends</span> <span class="title class_">ISource</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SOURCE source)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/13/skywalking-oap%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6/SegmentDispatcher.png" class="" title="SegmentDispatcher-继承体系">
<p>我们重点关注SegmentDispatcher</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentDispatcher</span> <span class="keyword">implements</span> <span class="title class_">SourceDispatcher</span>&lt;Segment&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Segment source)</span> &#123;</span><br><span class="line">        <span class="type">SegmentRecord</span> <span class="variable">segment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SegmentRecord</span>();</span><br><span class="line">        segment.setSegmentId(source.getSegmentId());</span><br><span class="line">        segment.setTraceId(source.getTraceId());</span><br><span class="line">        segment.setServiceId(source.getServiceId());</span><br><span class="line">        segment.setServiceInstanceId(source.getServiceInstanceId());</span><br><span class="line">        segment.setEndpointName(source.getEndpointName());</span><br><span class="line">        segment.setEndpointId(source.getEndpointId());</span><br><span class="line">        segment.setStartTime(source.getStartTime());</span><br><span class="line">        segment.setEndTime(source.getEndTime());</span><br><span class="line">        segment.setLatency(source.getLatency());</span><br><span class="line">        segment.setIsError(source.getIsError());</span><br><span class="line">        segment.setDataBinary(source.getDataBinary());</span><br><span class="line">        segment.setTimeBucket(source.getTimeBucket());</span><br><span class="line">        segment.setVersion(source.getVersion());</span><br><span class="line">        segment.setTagsRawData(source.getTags());</span><br><span class="line">        segment.setTags(Tag.Util.toStringList(source.getTags()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里就是要存到数据库了</span></span><br><span class="line">        RecordStreamProcessor.getInstance().in(segment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecordStreamProcessor"><a href="#RecordStreamProcessor" class="headerlink" title="RecordStreamProcessor"></a><code>RecordStreamProcessor</code></h3><p>还是代理模式,内部使用<code>RecordPersistentWorker</code>转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">(Record record)</span> &#123;</span><br><span class="line">    <span class="comment">//使用RecordPersistentWorker来处理</span></span><br><span class="line">        <span class="type">RecordPersistentWorker</span> <span class="variable">worker</span> <span class="operator">=</span> workers.get(record.getClass());</span><br><span class="line">        <span class="keyword">if</span> (worker != <span class="literal">null</span>) &#123;</span><br><span class="line">            worker.in(record);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecordPersistentWorker</span> <span class="keyword">extends</span> <span class="title class_">AbstractWorker</span>&lt;Record&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(RecordPersistentWorker.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Model model;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IRecordDAO recordDAO;</span><br><span class="line">    <span class="comment">//数据库的dao</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBatchDAO batchDAO;</span><br><span class="line"></span><br><span class="line">    RecordPersistentWorker(ModuleDefineHolder moduleDefineHolder, Model model, IRecordDAO recordDAO) &#123;</span><br><span class="line">        <span class="built_in">super</span>(moduleDefineHolder);</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="built_in">this</span>.recordDAO = recordDAO;</span><br><span class="line">        <span class="built_in">this</span>.batchDAO = moduleDefineHolder.find(StorageModule.NAME).provider().getService(IBatchDAO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">(Record record)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InsertRequest</span> <span class="variable">insertRequest</span> <span class="operator">=</span> recordDAO.prepareBatchInsert(model, record);</span><br><span class="line">            <span class="comment">//在这里,终于存到数据库dao了</span></span><br><span class="line">            batchDAO.insert(insertRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到大量使用了装饰者模式,层层委托,抽象非常多</p>
<ol>
<li><code>TraceSegmentReportServiceHandler</code>处理数据</li>
<li><code>SegmentParserServiceImpl</code>解析</li>
<li><code>traceAnalyzer</code>解析</li>
<li><code>MultiScopesAnalysisListener</code>解析</li>
<li><code>SourceReceiver</code>转发</li>
<li><code>DispatcherManager</code>转发</li>
<li><code>SourceDispatcher</code>转发</li>
<li><code>RecordStreamProcessor</code>最终使用dao执行</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>skyWalking</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>skywalking-ui简介</title>
    <url>/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="skyWalking-ui简介"><a href="#skyWalking-ui简介" class="headerlink" title="skyWalking-ui简介"></a>skyWalking-ui简介</h1><p><strong>基于<code>v8.7.0</code>版本</strong><br>skyWalking-UI是一个纯前端的项目,使用的是<code>vue</code>+<code>typescript</code>,但是<code>skywalking</code>为了方便用户使用,直接使用了<code>spring-gateway</code>打包成了可执行jar,方便用户使用</p>
<h3 id="UI概览"><a href="#UI概览" class="headerlink" title="UI概览"></a>UI概览</h3><p>其实<code>skywalking</code>的UI每个界面进去点点,看看名字,差不多就那样,这里不会详细的介绍每个界面,但是会系统性的介绍一些重点的界面,以及一些缺失的功能</p>
<h4 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h4><img src="/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/global.png" class="" title="global">

<ol>
<li>Services load（CPM - calls per minute）：服务平均每分钟请求数。</li>
<li>Slow Services（ms）：慢响应服务，单位ms。</li>
<li>Un-Health services（Apdex）：Apdex 性能指标，1为满分。</li>
<li>Slow Endpoints（ms）：全局维度的慢响应端点（API）。例如一个接口，是全局Top N的数据，通过这个可以观测平台性能情况。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表示采集样本中某些值的占比，Skywalking 有 “p50、p75、p90、p95、p99” 一些列值。</span><br><span class="line">图中的 “p99:61010” 表示 99% 请求的响应时间在61010ms以内。</span><br><span class="line">而99%一般用于抛掉一些极端值，表示绝大多数请求。</span><br></pre></td></tr></table></figure></li>
<li>Global Response Latency（percentile in ms）：全局响应延迟百分位数统计，单位 ms。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可译为热力图、热度图都可以，途中颜色越深，表示请求数越多，这和 GitHub Contributions 很像，commit 越多，颜色越深。</span><br><span class="line">横坐标是响应时间，鼠标放上去，可以看到具体的数量。</span><br><span class="line">通过热力图，一方面可以直观感受平台的整体流量，另一方面也可以感受整体性能。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><img src="/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/service.png" class="" title="service">

<ol>
<li>Service Apdex（数字）:当前服务的评分</li>
<li>Service Apdex（折线图）：一段时间内Apdex评分</li>
<li>Service Avg Response Times（ms）：平均响应延时，单位ms</li>
<li>Service Response Time Percentile：百分比响应延时，参考Global Response Latency（percentile in ms）</li>
<li>Successful Rate（数字）：请求成功率</li>
<li>Successful Rate（折线图）：一段时间的请求成功率</li>
<li>Servce Load（CPM &#x2F; PPM）（数字）：每分钟请求数，</li>
<li>Servce Load（CPM &#x2F; PPM）（折线图）：不同时间的每分钟请求数</li>
<li>Service Throughput （Bytes）：该指标只适用于TCP 服务。当前服务的吞吐量。</li>
<li>Servce Instances Load（CPM &#x2F; PPM）：每个服务实例的每分钟请求数</li>
<li>Show Service Instance：每个 服务 实例 的最大延时</li>
<li>Service Instance Successful Rate：每个服务实例的请求成功率</li>
</ol>
<h4 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h4><img src="/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/instance.png" class="" title="instance">

<ol>
<li>Service Instance Load （CPM &#x2F; PPM）：当前实例的每分钟请求数</li>
<li>Service Instance Throughput （Bytes）：该指标只适用于TCP 服务。当前服务实例的吞吐量。</li>
<li>Service Instance Successful Rate（%）：当前实例的请求成功率</li>
<li>Service Instance Latency（ms）：当前实例的响应延时</li>
<li>JVM CPU（Java Service）：jvm占用CPU的百分比</li>
<li>JVM Memory (Java Service)：JVM内存占用大小，单位m，包括堆内存，与堆外内存（直接内存）</li>
<li>JVM GC Time（ms）：JVM垃圾回收时间，包含YGC和OGC</li>
<li>JVM GC Count：JVM垃圾回收次数，包含YGC和OGC</li>
<li>JVM Thread Count (Java Service)<br>10 其他参数我就不介绍了，.net的东西。</li>
</ol>
<h4 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h4><img src="/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/endpoint.png" class="" title="endpoint">

<ol>
<li>Endpoint Load in Current Service（CPM &#x2F; PPM）：每个端点（API）每分钟请求数</li>
<li>Slow Endpoints in Current Service（ms）：每个端点（API）的最慢响应请求时间，单位ms</li>
<li>Successful Rate in Current Service（%）：每个端点（API）的请求成功率</li>
<li>接下来是每个端点的情况</li>
<li>Endpoint Load：当前端点每个时间段的请求数据</li>
<li>Endpoint Avg Response Time：当前端点每个时间段的请求行响应时间</li>
<li>Endpoint Response Time Percentile（ms）：当前端点每个时间段的响应时间占比</li>
<li>Endpoint Successful Rate（%）：当前端点每个时间段的请求成功率</li>
</ol>
<h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4>

<ol>
<li>Database Avg Response Time（ms）：当前数据库事件平均响应时间，单位ms</li>
<li>Database Access Successful Rate（%）：当前数据库访问成功率</li>
<li>Database Traffic（CPM: Calls Per Minute）：当前数据库每分钟请求数</li>
<li>Database Access Latency Percentile（ms）：数据库不同比例的响应时间，单位ms</li>
<li>Slow Statements（ms）：前N个慢查询，单位ms</li>
<li>All Database Loads（CPM: Calls Per Minute）：所有数据库中请求量排序</li>
<li>Un-Health Databases：所有数据库不健康排名，请求成功率排名，失败最多的请求在最上。</li>
</ol>
<h3 id="jvm监控"><a href="#jvm监控" class="headerlink" title="jvm监控"></a>jvm监控</h3><h4 id="没有心跳检测"><a href="#没有心跳检测" class="headerlink" title="没有心跳检测"></a>没有心跳检测</h4><p>没错,<code>skywalking</code>是没有心跳检测的,从界面上是看不到心跳相关的东西,但是<code>skywalking</code>的服务,有当前实例,实例里面有<code>jvm memory</code>,比如可以通过分析jvm的的堆从0开始增长<br>和变为0,来查看实例的存活情况,变相的达到心跳检测的结果.下面有查询时间,默认是查询最近15分钟的,所以,只要是在这个时间包含之内的,都可以查到</p>
<img src="/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/15min.png" class="" title="查询信息">
<img src="/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/timepicker.png" class="" title="时间范围选择">

<h4 id="只有堆和非堆"><a href="#只有堆和非堆" class="headerlink" title="只有堆和非堆"></a>只有堆和非堆</h4><p>只能堆内存和非堆内存,没有堆内存里面的详细信息,而且也只有<code>young gc</code>和<code>old gc</code>,没有<code>full gc</code></p>
<h3 id="vm-监控"><a href="#vm-监控" class="headerlink" title="vm 监控"></a>vm 监控</h3><p>vm监控使用的是<code>Prometheus</code>的<code>node-exporter</code>,然后通过<code>OpenTelemetry Collector</code>收集到<code>oap</code></p>
<ol>
<li>安装<code>node-exporter</code>启动</li>
<li>安装<code>OpenTelemetry Collector</code>并启动</li>
<li>修改<code>oap</code>的配置,重新启动</li>
</ol>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ol>
<li>安装<code>node-exporter</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v*/node_exporter-*.*-amd64.tar.gz</span><br><span class="line">tar xvfz node_exporter-*.*-amd64.tar.gz</span><br><span class="line">cd node_exporter-*.*-amd64</span><br><span class="line">./node_exporter --web.listen-address=:19100 # 如何需要启动别的端口,添加这个参数</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装<code>OpenTelemetry Collector</code>并启动</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM alpine:3.13 as certs</span><br><span class="line">RUN apk --update add ca-certificates</span><br><span class="line"></span><br><span class="line">FROM alpine:3.13 AS otelcol</span><br><span class="line">COPY otelcol /</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Note that this shouldn<span class="string">&#x27;t be necessary, but in some cases the file seems to be</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">copied with the execute bit lost (see #1317)</span></span></span><br><span class="line">RUN chmod 755 /otelcol</span><br><span class="line"></span><br><span class="line">FROM scratch</span><br><span class="line"></span><br><span class="line">ARG USER_UID=10001</span><br><span class="line">USER $&#123;USER_UID&#125;</span><br><span class="line"></span><br><span class="line">COPY --from=certs /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">COPY --from=otelcol /otelcol /</span><br><span class="line">COPY config.yaml /etc/otel/config.yaml</span><br><span class="line">ENTRYPOINT [&quot;/otelcol&quot;]</span><br><span class="line">CMD [&quot;--config&quot;, &quot;/etc/otel/config.yaml&quot;]</span><br><span class="line">EXPOSE 4317 55678 55679</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">receivers:</span></span><br><span class="line">  <span class="attr">prometheus:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">scrape_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;otel-collector&#x27;</span></span><br><span class="line">          <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">          <span class="attr">static_configs:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">targets:</span> [ <span class="string">&#x27;192.168.85.35:19100&#x27;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">batch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">exporters:</span></span><br><span class="line">  <span class="attr">opencensus:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">&quot;192.168.85.35:20630&quot;</span> <span class="comment"># The OAP Server address</span></span><br><span class="line">    <span class="attr">insecure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Exports data to the console</span></span><br><span class="line">  <span class="attr">logging:</span></span><br><span class="line">    <span class="attr">logLevel:</span> <span class="string">debug</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">pipelines:</span></span><br><span class="line">    <span class="attr">metrics:</span></span><br><span class="line">      <span class="attr">receivers:</span> [<span class="string">prometheus</span>]</span><br><span class="line">      <span class="attr">processors:</span> [<span class="string">batch</span>]</span><br><span class="line">      <span class="attr">exporters:</span> [<span class="string">opencensus</span>,<span class="string">logging</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name collector -v &quot;/etc/opentelemetry-collector/otel-collector-config.yaml&quot;:&quot;/etc/otel/config.yaml&quot; -p 54317:4317 -p 55678:55678 -p 55679:55679 otel/opentelemetry-collector:0.34.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改<code>oap</code>的配置,重新启动</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">receiver-otel:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="string">$&#123;SW_OTEL_RECEIVER:default&#125;</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">enabledHandlers:</span> <span class="string">$&#123;SW_OTEL_RECEIVER_ENABLED_HANDLERS:&quot;oc&quot;&#125;</span></span><br><span class="line">    <span class="attr">enabledOcRules:</span> <span class="string">$&#123;SW_OTEL_RECEIVER_ENABLED_OC_RULES:&quot;vm&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>效果如下</li>
</ol>
<img src="/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/vm.png" class="" title="vm监控信息">


<h3 id="追踪功能"><a href="#追踪功能" class="headerlink" title="追踪功能"></a>追踪功能</h3><p>追踪功能可以看到每次的请求,<code>skywalking</code>通过记录每次请求,来完成系统的各种分析,其中可以根据时间和tags进行过滤</p>
<ol>
<li>tags,注意必须配置了的tags才能搜索</li>
<li>还可以根据服务,实例,状态来查询</li>
</ol>
<h3 id="性能剖析"><a href="#性能剖析" class="headerlink" title="性能剖析"></a>性能剖析</h3><p>可以新建任务,采集固定的次数,然后根据采集的次数,可以通过代码堆栈来一步步分析,代码那里比较慢</p>
<h3 id="暂时不支持自定义指标"><a href="#暂时不支持自定义指标" class="headerlink" title="暂时不支持自定义指标"></a>暂时不支持自定义指标</h3><p>虽然<code>skywalking</code>可以自定义一些指标的样式,和是否显示,但是目前没有查到相关的资料,可以自定义指标,所以,目前只有官方的指标可以用,<strong>不过,如果想看某个接口的查询次数,可以在追踪里面查询,然后一页是15行,大致看出来这个接口的调用次数</strong></p>
<h3 id="告警功能-重点"><a href="#告警功能-重点" class="headerlink" title="告警功能(重点)"></a>告警功能(重点)</h3><p><a href="https://www.cnblogs.com/heihaozi/p/apache-skywalking-alarm.html">一片非常不错的告警讲解文章</a><br><a href="https://github.com/apache/skywalking/blob/master/docs/en/setup/backend/backend-alarm.md">官方文档</a><br><a href="https://skywalking.apache.org/zh/2020-12-13-skywalking-alarm/">发送到钉钉群</a><br>注意,如果不需要全部的<code>entity</code>,可以根据包含,排除,名称和标签,名字和regex,标签,多个维度来组合,达到精准的告警,比如根据包含,我只监控某个名称的<code>endpoint</code></p>
<p><code>label</code>是这样子的,可以查看指标的编辑页面看到,不是每个指标都有的</p>
<img src="/2021/09/22/skywalking-ui%E7%AE%80%E4%BB%8B/labels.png" class="" title="labels就是这样子">

<p>告警支持简单规则和复合规则,而且支持<code>webhooks</code>,目前支持<code>Webhook</code>,<code>gRPCHook</code>,<code>Slack Chat Hook</code>,<code>WeChat Hook</code>,<code>Dingtalk Hook</code>,<code>Feishu Hook</code>,<code>WeLink Hook</code></p>
<h5 id="常用的指标简介"><a href="#常用的指标简介" class="headerlink" title="常用的指标简介"></a>常用的指标简介</h5><ol>
<li><code>endpoint_avg</code>,针对全部<code>endpoint</code>,可以告警响应时间,可以根据包含,监控重点业务的响应时间,超时就报警</li>
<li><code>endpoint_sla</code>,针对全部<code>endpoint</code>,监控成功率,配置成小于100%,那就是有失败就告警</li>
<li><code>vm</code>监控里面的<code>meter_vm_cpu_total_percentage</code>,cpu全部负载平均值,可以查看vm是否负载严重</li>
<li><code>vm</code>监控里面的<code>meter_vm_memory_used</code>,内存使用,可以查看vm内存是否耗尽,一般来说,cpu超负荷,内存爆满,就是机器要挂的征兆</li>
</ol>
<p>以下是一个实例配置,特定的<code>endpoint</code>响应时间,10分钟一个周期,超过一次就报警,如果你想超过就报警,就把周期设置短一些,比如1分钟报警一次,这样10分钟就能报警10次</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">endpoint_avg_laon_login_rule:</span></span><br><span class="line"> <span class="attr">metrics-name:</span> <span class="string">endpoint_avg</span></span><br><span class="line"> <span class="attr">include-names:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&#x27;&#123;POST&#125;/login in ladon&#x27;</span></span><br><span class="line"> <span class="attr">op:</span> <span class="string">&quot;&gt;&quot;</span></span><br><span class="line"> <span class="attr">threshold:</span> <span class="number">10</span></span><br><span class="line"> <span class="attr">period:</span> <span class="number">10</span></span><br><span class="line"> <span class="attr">count:</span> <span class="number">1</span></span><br><span class="line"> <span class="attr">message:</span> <span class="string">Response</span> <span class="string">time</span> <span class="string">of</span> <span class="string">endpoint</span> &#123;<span class="string">name</span>&#125; <span class="string">is</span> <span class="string">more</span> <span class="string">than</span> <span class="string">10ms</span> <span class="string">in</span> <span class="number">10</span> <span class="string">minutes</span> <span class="string">of</span> <span class="string">last</span> <span class="number">10</span> <span class="string">minutes</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>skyWalking</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot传参解析</title>
    <url>/2022/02/28/springBoot%E4%BC%A0%E5%8F%82%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="springBoot传参解析"><a href="#springBoot传参解析" class="headerlink" title="springBoot传参解析"></a>springBoot传参解析</h1><p><code>springBoot</code>分为好几个环境,开发和测试,生产肯定不一样,一般来说都是通过命令行传参确定使用那个profile</p>
<img src="./spring-boot-logo.svg" width="222" height="222" alt="springBootLogo" title="springBoot">

<h3 id="先复制粘贴一下文档-看看springBoot传参的优先级吧"><a href="#先复制粘贴一下文档-看看springBoot传参的优先级吧" class="headerlink" title="先复制粘贴一下文档,看看springBoot传参的优先级吧"></a>先复制粘贴一下文档,看看springBoot传参的优先级吧</h3><ol>
<li>Default properties (specified by setting SpringApplication.setDefaultProperties).</li>
<li>@PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.</li>
<li>Config data (such as application.properties files).</li>
<li>A RandomValuePropertySource that has properties only in random.*.</li>
<li>OS environment variables.</li>
<li>Java System properties (System.getProperties()).</li>
<li>JNDI attributes from java:comp&#x2F;env.</li>
<li>ServletContext init parameters.</li>
<li>ServletConfig init parameters.</li>
<li>Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).</li>
<li>Command line arguments.</li>
<li>properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.</li>
<li>@TestPropertySource annotations on your tests.</li>
<li>Devtools global settings properties in the $HOME&#x2F;.config&#x2F;spring-boot directory when devtools is active.</li>
</ol>
<p>14个优先级,看起来非常多,比较复杂,而且存在优先级,那就意味着,<strong>都是根据优先级覆盖的,可能你明明没配,但是优先级低的配了,你必须要覆盖才能修改</strong>  </p>
<p>虽然优先级很多,但是实际使用的时候,注意一下即可,给你那么多选择,你可以不用</p>
<h3 id="较好的实践"><a href="#较好的实践" class="headerlink" title="较好的实践"></a>较好的实践</h3><ol>
<li>非docker环境,可以使用命令行传参</li>
<li>docker环境,可以使用System properties.</li>
</ol>
<h3 id="传参的两种方式"><a href="#传参的两种方式" class="headerlink" title="传参的两种方式"></a>传参的两种方式</h3><ol>
<li><code>-Dspring.profiles.active=dev -Dserver.port=8080</code>,这是java的方式</li>
<li><code>--spring.profiles.active=dev --server.port=8080</code>这是<code>springBoot</code>特有的方式,这个是命令行参数,所以应该放到最后面</li>
</ol>
<p>spring给的方式挺多的,但是感觉java的方式就够了,至于<code>--</code>这种命令行的方式,是<code>springBoot</code>自创的,只有<code>springBoot</code>封装了一下,你知道就行了,</p>
<h3 id="jar的配置文件"><a href="#jar的配置文件" class="headerlink" title="jar的配置文件"></a>jar的配置文件</h3><p>自从<code>springBoot</code>方便的使用可执行jar以后,问题就来了,改jar里面的配置文件很麻烦怎么办,这是一个问题,不过spring早想到这了这点,所以,它又提供了优先级的方案,大概是这样</p>
<p>From the classpath</p>
<ol>
<li>The classpath root</li>
<li>The classpath &#x2F;config package</li>
</ol>
<p>From the current directory</p>
<ol>
<li>The current directory</li>
<li>The &#x2F;config subdirectory in the current directory</li>
<li>Immediate child directories of the &#x2F;config subdirectory</li>
</ol>
<p>没错,使用配置文件的时候,也有很多优先级,classpath的优先级低,当前文件夹的优先级高,而且当前文件夹的时候,还有优先级</p>
<p>较佳实践</p>
<ol>
<li>直接当前文件夹配置文件</li>
<li>config配置文件</li>
<li>使用<code>spring.config.location</code>显式指定,但是应该没太大必要,一般,前两种就够了,毕竟,约定大于配置,既然约定好了,就用</li>
</ol>
<h3 id="文档引用地址"><a href="#文档引用地址" class="headerlink" title="文档引用地址"></a>文档引用地址</h3><p>其实spring文档真的很不错<br><a href="https://docs.spring.io/spring-boot/docs/2.7.x/reference/html/features.html#features.external-config" 
title="spring2.7的文档">spring2.7的文档额外配置特性</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解一下<code>springBoot</code>配置的优先级,以及命令行传参的两种方式,还有使用文件配置的时候,如果jar外面配置,基本够用了</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>traefik简单介绍</title>
    <url>/2023/04/14/traefik%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="traefik简单介绍"><a href="#traefik简单介绍" class="headerlink" title="traefik简单介绍"></a>traefik简单介绍</h1><p>nginx大家都很清楚,家喻户晓,从apache,到nginx,几乎开启了一个新时代,但是这么多年以来,软件的发展迅速,各种新事物层出不穷,微服务,devops,集群,k8s等等<br>出现,再也不是原来一个简简单单的web,不可能再重新部署以下服务,然后nginx重新启动一下这么简单了,所以,现在需要一个功能强大,比如tcp,http,而且需要支持<br>动态部署,比如服务新增或者挂掉以后,能自动代理,无需人为干预</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="边缘路由-edge-router"><a href="#边缘路由-edge-router" class="headerlink" title="边缘路由 edge router"></a>边缘路由 edge router</h3><p>比如nginx是http服务器,但是traefik几乎可以代理所有的网络服务,比如redis,mysql,这些是tcp系列的,还有http系列的,边缘路由,就是很强大的路由,一个能代理几乎<br>一切的路由<a href="https://doc.traefik.io/traefik/getting-started/concepts/">这是官网的描述</a></p>
<h3 id="自动服务发现-auto-service-discovery"><a href="#自动服务发现-auto-service-discovery" class="headerlink" title="自动服务发现 auto service discovery"></a>自动服务发现 auto service discovery</h3><p>把你服务部署的时候,附加上路由信息,traefik可以自动获取配置信息,来路由,当你的服务移除的时候,traefik也可以自动发现, 去移除,这一切都是自动的,你无需去同步配置,然后<br>重启</p>
<h2 id="traefik-架构"><a href="#traefik-架构" class="headerlink" title="traefik 架构"></a>traefik 架构</h2><img src="/2023/04/14/traefik%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/architecture_overview.png" class="" title="traefik架构">

<ol>
<li>Providers负责发现服务</li>
<li>Entrypoints 监听等待请求</li>
<li>Routers 分析请求</li>
<li>Services 转发分析过后的请求</li>
<li>Middlewares 修改相关的请求</li>
</ol>
<h3 id="Entrypoints"><a href="#Entrypoints" class="headerlink" title="Entrypoints"></a>Entrypoints</h3><p>支持http,tcp,udp,而且可以同时监听多个,http支持 http&#x2F;1,http&#x2F;2,http&#x2F;3,同时http转发的那些常见功能,非常丰富</p>
<h3 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h3><p>通过host,header,path,query,clientIp分分发请求</p>
<h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><p>配置服务的host,port,scheme等相关信息,Entrypoints支持tcp,udp,http,所以,服务可以是http,也可以是mysql,redis这样的中间件,对应tcp</p>
<h3 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h3><p>可以是docker,k8s,也可以是kv数据库,比如redis,详情请查看官网,支持的比较丰富,如果是docker,k8s可以自动,如果是kv数据库的话,需要自己放置配置<br>,比较麻烦<a href="https://doc.traefik.io/traefik/providers/overview/#supported-providers">详细的配置</a></p>
<h3 id="middleWare"><a href="#middleWare" class="headerlink" title="middleWare"></a>middleWare</h3><p>其实就是针对route做一些操作,比如addPrefix,ReplacePath,Buffering等相关针对http的操作</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单介绍一下traefik,初步有个概念,另外官网的文档其实还是很齐全的,有需要,可以好好看看<a href="https://doc.traefik.io/traefik/">官网的文档</a></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>traefik</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware的3D性能有多强</title>
    <url>/2022/09/14/vmware%E7%9A%843D%E6%80%A7%E8%83%BD%E6%9C%89%E5%A4%9A%E5%BC%BA/</url>
    <content><![CDATA[<h1 id="vmware的3D性能有多强"><a href="#vmware的3D性能有多强" class="headerlink" title="vmware的3D性能有多强"></a>vmware的3D性能有多强</h1><p>很强,大概70%左右吧,无论是windows平台还是linux平台,都差不多是这个结果,可能windows的72%左右,linux的68%,所以,只要你原来的显卡很强,就可以一直强</p>
<h2 id="如何测试"><a href="#如何测试" class="headerlink" title="如何测试"></a>如何测试</h2><p>其实测试的时候,使用鲁大师测试的,并不怎么严格,但是差不多就行了,比如rx460,本来能跑到7w分,但是虚拟机里面就能跑到5w分,1GB显存的情况,还有一些up主,也看他们的视频,也用的鲁大师,差不多就是70%左右的样子,但是他们是windows</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>我是虚拟机重度用户,qemu的话,因为只有一个显卡,不能显卡直通,所以,暂时virtualBox和vmware是主力</p>
<ol>
<li>virtualBox适合跑一些后台任务,也很稳定,而且占用可能会少一些吧</li>
<li>vmware适合桌面办公,它的增强工具更稳定,可以十天半个月不关机还是好好的,virtualbox就不行了,可能用个几天就会出问题</li>
</ol>
<h2 id="vmware优化"><a href="#vmware优化" class="headerlink" title="vmware优化"></a>vmware优化</h2><ol>
<li>内存给够,这个看你需求,vmware有个所有虚拟机的内存限制,调高一些,只是max限制而已,而且一下子把内存分配好,不要让它使用交换内存,这样性能肯定有折扣的<img src="/2022/09/14/vmware%E7%9A%843D%E6%80%A7%E8%83%BD%E6%9C%89%E5%A4%9A%E5%BC%BA/vmware%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE.png" class="" title="vmware内存配置"></li>
<li>cpu给够,有些人害怕虚拟机占用资源多,给的少,但是我觉得cpu其实是按需使用的,你给的多了,也是差不多的,所以,直接梭哈给,还更快一些</li>
<li>vmware在linux下面默认是不使用显卡的,所以,3D性能非常差,需要<code>~/.vmware/preferences</code>添加这个,让它使用显卡,否则几乎没有3D性能,就没有那个70%<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mks.gl.allowBlacklistedDrivers = &quot;TRUE&quot;</span><br></pre></td></tr></table></figure></li>
<li><strong>linux不要用新的内核</strong>,因为vmware是闭源的,用新的内核会很卡,总是cpu占用莫名奇妙的高,需要用稍微老点的lts内核,比如说,老上3年,就差不多了,这个是vmware的特性导致的,virtualbox对新内核的支持就要好很多</li>
<li>显示支持3D,同时显存看你的需要,相对应的分配大一些</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你不爱折腾,不使用qemu-kvm的显卡直通,基本上,vmware的显卡性能真的很强了,但是可以玩游戏嘛?可能还是不行,毕竟是虚拟机,玩游戏要求鼠标不飘,性能稳定,但是虚拟机可能会卡一下,或者玩游戏的时候鼠标有些飘</p>
<h2 id="如何显卡更强-显卡直通"><a href="#如何显卡更强-显卡直通" class="headerlink" title="如何显卡更强,显卡直通"></a>如何显卡更强,显卡直通</h2><p>下次,我多买块显卡,来个qemu-kvm的显卡直通试试,这下显卡直通了,用的驱动直接就是本身显卡的驱动,不再是SVGA显卡驱动,很更强,现在就一块独显,我也搞不了,以后有机会再写一篇</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>windows读取usb硬盘xfs文件系统的文件</title>
    <url>/2021/07/08/windows%E8%AF%BB%E5%8F%96usb%E7%A1%AC%E7%9B%98xfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="windows读取usb硬盘xfs文件系统的文件"><a href="#windows读取usb硬盘xfs文件系统的文件" class="headerlink" title="windows读取usb硬盘xfs文件系统的文件"></a>windows读取usb硬盘xfs文件系统的文件</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为自己家里的电脑是linux,而且喜欢linux的文件系统,所以整个移动硬盘都是xfs的文件格式,而现在公司的电脑是windows,要复制文件就比较艰难</p>
<h2 id="狗哥一下"><a href="#狗哥一下" class="headerlink" title="狗哥一下"></a>狗哥一下</h2><p>发现网上的方案都是使用软件,而且软件也不怎么样,总之就是没有找到像样的软件,尤其是xfs还不是ext4</p>
<h2 id="使用虚拟机"><a href="#使用虚拟机" class="headerlink" title="使用虚拟机"></a>使用虚拟机</h2><ol>
<li>先装一个virtualbox</li>
<li><code>Oracle_VM_VirtualBox_Extension_Pack</code>安装,这样才能使用外置的usb硬盘</li>
<li>下一个linux的live镜像,如<code>manjaro kde</code></li>
<li>usb设置里面挂载usb硬盘</li>
<li>新创建一个vhd硬盘挂载</li>
<li>把vhd硬盘新建分区,并且格式化成ntfs格式</li>
<li>把usb移动硬盘的文件,copy到vhd硬盘里面</li>
<li>最好关机以后,用windows自带的<code>磁盘管理</code>挂载vhd硬盘</li>
<li>复制你的文件到你想要的位置</li>
</ol>
<img src="/2021/07/08/windows%E8%AF%BB%E5%8F%96usb%E7%A1%AC%E7%9B%98xfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6/disk_manager.png" class="" title="windows的磁盘管理">

<p>还是比较费劲的,但是也没办法.如果你有现成的linux虚拟机,并且装好了<code>VBoxGuestAdditions</code><br>,那么事情就比较简单了,直接可以把usb硬盘挂载了以后,利用virtualbox的共享文件夹,直接复制到windows,这样就好办多了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是比较费劲的,但是也没办法,需求.不过linux可是能比较好的识别windows的硬盘</p>
<h2 id="升华"><a href="#升华" class="headerlink" title="升华"></a>升华</h2><p>目前wsl2支持挂载usb硬盘,但是我的不是预览版,功能还没有,如果你是预览版的,或者以后wsl2升级了,那么windows使用linux文件的系统,应该会简单很多</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>xfs</tag>
      </tags>
  </entry>
  <entry>
    <title>公司网络配置</title>
    <url>/2021/11/21/%E5%85%AC%E5%8F%B8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="公司网络的额外配置"><a href="#公司网络的额外配置" class="headerlink" title="公司网络的额外配置"></a>公司网络的额外配置</h1><p>公司使用了安全管理,然后只能支持win和mac,那我想使用linux,就必须使用额外的方法</p>
<img src="/2021/11/21/%E5%85%AC%E5%8F%B8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/h.jpg" class="" title="网络">

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用windows的共享网络,具体就是windows的虚拟机两块网卡,然后第一块网卡设置成网络可以共享,第二块网卡充当路由的角色,就可以实现网络共享</p>
<h2 id="第一种实现"><a href="#第一种实现" class="headerlink" title="第一种实现"></a>第一种实现</h2><p>原来的想法很简单,就是虚拟机两块桥接的网卡,然后第二块网卡自动时出137的网段,然后我的电脑配置成137的ip,就可以了</p>
<p>不过这样的配置,有个非常明显的缺点,那就是局域网有了dhcp的服务,所有的电脑设置成自动ip都可以默认上网,显然,这样做是不行的</p>
<h2 id="升级后的实现"><a href="#升级后的实现" class="headerlink" title="升级后的实现"></a>升级后的实现</h2><p>不能用两块桥接的网卡,第二块网卡使用主机网络,同时不配置dhcp服务器</p>
<img src="/2021/11/21/%E5%85%AC%E5%8F%B8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/network_manager.png" class="" title="主机网络">

<p>然后同一个网段的虚拟机就可以上网了,但是主机却无法上网,还需要每次开机额外的配置,不过我经常不关电脑,只是睡眠,所以说问题也不大</p>
<h3 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ip link set vboxnet0 up</span><br><span class="line">sudo ip route add 192.168.137.1 dev vboxnet0</span><br><span class="line">sudo ip route add default via 192.168.137.1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存redis,hazelcast,ignite,infinispan简介</title>
    <url>/2022/12/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98redis-hazelcast-ignite-infinispan%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="分布式缓存redis-hazelcast-ignite-infinispan简介"><a href="#分布式缓存redis-hazelcast-ignite-infinispan简介" class="headerlink" title="分布式缓存redis,hazelcast,ignite,infinispan简介"></a>分布式缓存redis,hazelcast,ignite,infinispan简介</h1><p>本文主要简单的介绍一下这些分布式缓存中间件,了解其基本原理</p>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>redis国内其实很火,虽然redis很火,性能很给力,但是redis本质上是个单线程的单机缓存,不过redis6.0以后增加了多线程,本期要了解分布式缓存,所以,顺带也说一下能把reids变成分布式的技术</p>
<ol>
<li>主从</li>
<li>分片</li>
</ol>
<p>其实思路很像mysql支持集群,但是归根到底,redis是一个单体缓存,如果变成分布式,其实mysql已经有了很多经验,完全可以类比</p>
<h3 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h3><p>主从,其实严格来讲不是分布式,只是高可用的一种</p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>因为redis本身是个单体缓存,所以,要支持分布式,就需要分片,这个时候,其实就有很多思路,比如proxy模式的sever分片,和客户端分片之类等等的方案</p>
<h2 id="infinispan"><a href="#infinispan" class="headerlink" title="infinispan"></a>infinispan</h2><p>infinispan是redhat的,国内的资料比较少,人气也很少,就不介绍了,你只需要知道它也是个分布式缓存,混个脸熟即可</p>
<h2 id="hazelcast和ignite的相同之处"><a href="#hazelcast和ignite的相同之处" class="headerlink" title="hazelcast和ignite的相同之处"></a>hazelcast和ignite的相同之处</h2><p>hazelcast和ignite其实很像,各方面都很像,就连github的start数量也很像,一个4.3k,一个5.1k,infinispan就1k,所以前两个很像</p>
<img style="background-color: aqua;width: 300px;" src="./hazelcast.svg" alt="hazelcast logo" title="hazelcast logo">
<img style="background-color: aqua;width: 300px;" src="./ingite.svg" alt="ingite logo" title="ingite logo">

<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>分布式实现的时候,基本上最少需要两种角色,一个是调控,一个是干活,当然细分还有很多,所有,分布式环境中,部署的节点,一种是对等的,一种是不对等的,对等的就是直接加节点,不对等的,需要按照一定的逻辑,相应的加节点</p>
<ol>
<li>节点都是对等的,直接添加</li>
<li>部署方式,均支持嵌入式和独立部署</li>
</ol>
<h3 id="都有控制中心"><a href="#都有控制中心" class="headerlink" title="都有控制中心"></a>都有控制中心</h3><p>hazelcast的叫Management Center,ignite的是GridGain Control<br>Center,没错是GridGain的,因为GridGain就是ignite的商业版本,GridGain就是基于ignite的</p>
<h3 id="性能也都差不多"><a href="#性能也都差不多" class="headerlink" title="性能也都差不多"></a>性能也都差不多</h3><p>两家对比过benchmark,后来伤了和气,没有比了,网上的资料也比较少,但是hazelcast放的资料是比ignite快一些</p>
<h3 id="商业方式"><a href="#商业方式" class="headerlink" title="商业方式"></a>商业方式</h3><p>商业方式也差不多,都有开源的,然后有商业版本</p>
<h2 id="hazelcast和ignite的不同之处"><a href="#hazelcast和ignite的不同之处" class="headerlink" title="hazelcast和ignite的不同之处"></a>hazelcast和ignite的不同之处</h2><p>ignite开源版本之处堆外缓存,但是hazelcast只有商业版本才支持,以下的链接是各自和自己的商业版本对比</p>
<ol>
<li><a href="https://hazelcast.com/product-features/feature-comparison/">hazelcast和自己的商业版本对比</a>,安全和存储等方面的特性支持</li>
<li><a href="https://www.gridgain.com/products/in-memory-computing-platform">ignite和自己的商业版本对比</a>,商业版本主要增加了备份,压缩等功能</li>
</ol>
<p>总体来说,个人感觉,ignite的功能要比hazelcast的功能多一些,开源版本也更良心一些,仅供参考</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>分布式缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>基于mybatisPlus的多库支持实践</title>
    <url>/2022/04/22/%E5%9F%BA%E4%BA%8EmybatisPlus%E7%9A%84%E5%A4%9A%E5%BA%93%E6%94%AF%E6%8C%81%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="基于mybatisPlus的多库支持实践"><a href="#基于mybatisPlus的多库支持实践" class="headerlink" title="基于mybatisPlus的多库支持实践"></a>基于mybatisPlus的多库支持实践</h1><p>开发中, 存在一种这样的业务场景,就是我们的应用要支持多库,同一个应用,我a项目用mysql,b项目用oracle</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>充分利用sql的特性,和代码的特性,以及框架本身的特性,用最小的代价,来完成应用对多库的支持</p>
<h2 id="多库支持原则"><a href="#多库支持原则" class="headerlink" title="多库支持原则"></a>多库支持原则</h2><ol>
<li>最小代价原则,充分利用sql的特性,充分利用代码的特性,利用框架的特性</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>在使用mybatis plus过程中,有两种dao风格,一种是dsl风格,使用wrapper类,一种是需要join的sql,一般使用xml里面配置</li>
<li>从sql的角度入手,无论是oracle还是mysql,虽然差异也是有的,但是sql本身也是有规范的,所以,大部分简单sql本身就是支持oracle和mysql的,使用了函数的sql,或者groupby的sql一般是不能支持多db的,只需要关注差异化的sql即可</li>
<li>分页,分页每个数据库都不一样,mysql和postgresql完全一样,但是oracle比较古老,分页的sql也相对复杂,所以,分页各不一样</li>
</ol>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="差异语句-使用wrapper"><a href="#差异语句-使用wrapper" class="headerlink" title="差异语句,使用wrapper"></a>差异语句,使用wrapper</h3><p>一般wrapper使用了<code>last</code>,<code>apply</code>等函数的,一定是需要差异化处理的,这个时候,可以,自己配置springbootde的参数,根据参数来确定使用那种语句,而且多个<br>地方使用同一个语句的话,还可以抽象成一个函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">substrNodeFlag</span><span class="params">()</span> &#123;</span><br><span class="line">    String subStr;</span><br><span class="line">    <span class="type">DbType</span> <span class="variable">dbType</span> <span class="operator">=</span> plbPaginationProperties.getPagination();</span><br><span class="line">    <span class="keyword">switch</span> (dbType) &#123;</span><br><span class="line">        <span class="keyword">case</span> ORACLE:</span><br><span class="line">        <span class="keyword">case</span> DB2: &#123;</span><br><span class="line">            subStr = <span class="string">&quot;node_Flag = substr(node_Flag,0,&quot;</span> + (Node.PUSH.getIndex() * <span class="number">2</span>) + <span class="string">&quot;)||&quot;</span></span><br><span class="line">                    + NodeStatus.Push.SUCCESS.code() + <span class="string">&quot;||substr(node_Flag,&quot;</span> + (Node.PUSH.getIndex() * <span class="number">2</span> + <span class="number">2</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MYSQL: &#123;</span><br><span class="line">            subStr = <span class="string">&quot;node_Flag = substring(node_Flag,0,&quot;</span> + (Node.PUSH.getIndex() * <span class="number">2</span>) + <span class="string">&quot;)||&quot;</span></span><br><span class="line">                    + NodeStatus.Push.SUCCESS.code() + <span class="string">&quot;||substring(node_Flag,&quot;</span> + (Node.PUSH.getIndex() * <span class="number">2</span> + <span class="number">2</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;unSupport dbType [%s]&quot;</span>, dbType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="差异化sql-分开成不同的xml"><a href="#差异化sql-分开成不同的xml" class="headerlink" title="差异化sql,分开成不同的xml"></a>差异化sql,分开成不同的xml</h3><p>因为mybatis允许一个dao文件,对应多个xml,如果一个xml文件里面的sql需要差异化处理,可以非差异化的sql放到一个文件里面,然后差异化的sql,放到各自的文件夹里面,<br>最后通过配置来区分</p>
<img src="/2022/04/22/%E5%9F%BA%E4%BA%8EmybatisPlus%E7%9A%84%E5%A4%9A%E5%BA%93%E6%94%AF%E6%8C%81%E5%AE%9E%E8%B7%B5/xml-floder.png" class="" title="xml区分开">
<ol>
<li>oracle和mysql都可以用的文件放到这里</li>
<li>mysql专用的sql</li>
<li>oracle专用的sql</li>
</ol>
<p>配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mapperLocations:</span> <span class="string">classpath*:mappers/*.xml,classpath*:oraclemappers/*.xml</span> <span class="comment">#这里是使用的oracle环境</span></span><br></pre></td></tr></table></figure>

<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>springboot里面配置一个参数,然后通过不同的参数,构建不同数据库的分页插件即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PaginationProperties paginationProperties; <span class="comment">//配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">(CustomDataPermissionInterceptor customDataPermissionInterceptor)</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(customDataPermissionInterceptor);</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(paginationProperties.getPagination())); <span class="comment">//构建</span></span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="id自增问题"><a href="#id自增问题" class="headerlink" title="id自增问题"></a>id自增问题</h3><p>因为mysql很容易实现id自增,然后oracle id自增比较麻烦,所以,使用oracle的时候,可以自定义一个id序列,如使用雪花算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;ladon&quot;, matchIfMissing = true, name = &quot;pagination&quot;, havingValue = &quot;ORACLE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> IdentifierGenerator <span class="title function_">customIdGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomIdGenerator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ol>
<li>如果查看项目里面那些地方有差异化sql,直接使用全文检索即可</li>
</ol>
<img src="/2022/04/22/%E5%9F%BA%E4%BA%8EmybatisPlus%E7%9A%84%E5%A4%9A%E5%BA%93%E6%94%AF%E6%8C%81%E5%AE%9E%E8%B7%B5/difference.png" class="" title="差异化sql">
<img src="/2022/04/22/%E5%9F%BA%E4%BA%8EmybatisPlus%E7%9A%84%E5%A4%9A%E5%BA%93%E6%94%AF%E6%8C%81%E5%AE%9E%E8%B7%B5/difference-xml.png" class="" title="差异化sql-xml">
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>多库支持</tag>
      </tags>
  </entry>
  <entry>
    <title>开源报表平台调研</title>
    <url>/2022/10/14/%E5%BC%80%E6%BA%90%E6%8A%A5%E8%A1%A8%E5%B9%B3%E5%8F%B0%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h1 id="开源报表平台调研"><a href="#开源报表平台调研" class="headerlink" title="开源报表平台调研"></a>开源报表平台调研</h1><p>目前市面上有一些流行的开源BI平台,看样子还很不错,而且功能也比较强大,在这里简单的对比一下它们,从功能到实现</p>
<h2 id="接下来是几个比较出名的BI"><a href="#接下来是几个比较出名的BI" class="headerlink" title="接下来是几个比较出名的BI"></a>接下来是几个比较出名的BI</h2><h3 id="datart"><a href="#datart" class="headerlink" title="datart"></a>datart</h3><p>datart 是新一代数据可视化开放平台，支持各类企业数据可视化场景需求，如创建和使用报表、仪表板和大屏，进行可视化数据分析，构建可视化数据应用等。<br>由原 davinci 主创团队出品，datart 更加开放、可塑和智能，并在数据与艺术之间寻求最佳平衡  </p>
<ol>
<li>文档比较丰富</li>
<li>设计理念完善</li>
<li>功能非常强大</li>
</ol>
<h3 id="JimuReport"><a href="#JimuReport" class="headerlink" title="JimuReport"></a>JimuReport</h3><p>主要功能是那种打印的报表,然后大屏bi是收费的,pass</p>
<h3 id="EasyReport"><a href="#EasyReport" class="headerlink" title="EasyReport"></a>EasyReport</h3><p>个人项目,功能比较弱,虽然是BI,但是好像没有BI功能 pass</p>
<h3 id="CBoard"><a href="#CBoard" class="headerlink" title="CBoard"></a>CBoard</h3><p>企业开源,但是界面看起来比较朴素,而且功能比较弱 待定</p>
<h3 id="SmartChart"><a href="#SmartChart" class="headerlink" title="SmartChart"></a>SmartChart</h3><p>python编写,功能抽象度比较低,偏向于代码编写,但是仍有借鉴意义,可以借鉴,但是因为技术栈不一样,所以仅供参考</p>
<h3 id="datagear"><a href="#datagear" class="headerlink" title="datagear"></a>datagear</h3><p>功能比较强大,前端偏向于diy,可以直接自定义前端的内容,及时生效,前端比较强大</p>
<h3 id="Davinci"><a href="#Davinci" class="headerlink" title="Davinci"></a>Davinci</h3><p>功能强大,和datart有很多相似之处,很多地方可以借鉴</p>
<h3 id="dataease"><a href="#dataease" class="headerlink" title="dataease"></a>dataease</h3><p>可视化做得非常好,抽象非常多,数据集之间的转换非常容易,支持的组建相对比较丰富</p>
<h2 id="进一步对比"><a href="#进一步对比" class="headerlink" title="进一步对比"></a>进一步对比</h2><p>其实国外也有很多优秀的bi,但是相比之下,并不适应国内的行情,所以,并没有参考国外的</p>
<p>综合之下,入选的这些bi分别是</p>
<ol>
<li>datart</li>
<li>Davinci</li>
<li>datagear</li>
<li>dataease</li>
</ol>
<p>只起到参考意义的组件是</p>
<ol>
<li>CBoard</li>
<li>SmartChart</li>
</ol>
]]></content>
      <categories>
        <category>BI</category>
      </categories>
      <tags>
        <tag>BI</tag>
      </tags>
  </entry>
  <entry>
    <title>我为什么从vz</title>
    <url>/2022/10/05/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Evz/</url>
    <content><![CDATA[<h1 id="我为什么从微众离职"><a href="#我为什么从微众离职" class="headerlink" title="我为什么从微众离职"></a>我为什么从微众离职</h1><p>微众并不是一家适合长久发展的公司</p>
<img src="/2022/10/05/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Evz/service_effect_logo.png" class="" title="微众logo">

<h2 id="画虎画皮难画骨"><a href="#画虎画皮难画骨" class="headerlink" title="画虎画皮难画骨"></a>画虎画皮难画骨</h2><p>和领导同事聊过,还有自己平常也都看到了,公司人员流动很大,老员工也快走光了,最近直接上司,6年的老员工,差不多第一批,也走了,<br>有时候能直接跑一批,来的全都是新人,公司的产品问题也很多,关键是还解决不了</p>
<ol>
<li>高层浮躁,不会想着用心打磨一个产品,主营业务,擅长的不好好做,总是想着如何去迎合市场,去投机,做了一大堆没用的东西,来的时候就火急火燎的做了一个智能贷后,忙活三个月,结果到最后,几乎没什么项目,我给同事吐槽<br>同事给我讲,这样的东西还很多呢</li>
<li>中层缺乏技术,总是想着如何糊弄过去,不会认真的考虑以后怎么办,每次都当救火队员,但是从不真正地解决问题,最近日志脱敏,也是想着先用正则糊弄过去,我当场就提了,正则效率很差,性能既有可能扛不住,结果,<br>用正则的版本线上直接cpu爆表然后,关闭了,我这边做的非正则版本,花时间做的,全面避免了正则,效果不错</li>
<li>底层更是缺乏技术和规范,混乱不堪,代码上线以后,连对应的版本都找不到,写东西,更是不讲究效率,毫无章法,写出来的东西,效率很低,稍微并发高一点,性能就出问题</li>
</ol>
<p>整个公司,2014成立,都8年了,基本的产品都不稳定,信誉越来越差,高层浮躁,中层也是没有人敢指出来  </p>
<p>不像我们公司一样,早早都是借鉴了行业的优秀思路,提出了产品化的策略,以产品化为原型,然后,支持项目,我觉得这个思路还是非常好的</p>
<h2 id="我希望的公司"><a href="#我希望的公司" class="headerlink" title="我希望的公司"></a>我希望的公司</h2><p>其实我到那个公司,都是希望好好干的,我本身写代码也有洁癖</p>
<ol>
<li>希望能在技术上多做发展,那些有挑战性的东西,可以拉上我</li>
<li>比如jvm优化,我这边原来做到,用的jprofiler,优化效果非常明显,找出了很多隐藏的问题,比如喜欢new objectMapper,然后脚本编译完成以后,不缓存,然后循环编译,都是一些非常耗时的操作</li>
<li>还有我这边在低代码方面的流程编排方面也做了一些研究,比如flowable最近一直在用,还有动态脚本方方面,都做了一些研究,比如aviatorScript,groovy script,属于低代码的领域,也可以用到</li>
</ol>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>神舟笔记本每次开机都要自己打开wifi的解决问题记录</title>
    <url>/2021/07/08/%E7%A5%9E%E8%88%9F%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%AF%8F%E6%AC%A1%E5%BC%80%E6%9C%BA%E9%83%BD%E8%A6%81%E8%87%AA%E5%B7%B1%E6%89%93%E5%BC%80wifi%E7%9A%84%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="神舟笔记本每次开机都要自己打开wifi的解决问题记录"><a href="#神舟笔记本每次开机都要自己打开wifi的解决问题记录" class="headerlink" title="神舟笔记本每次开机都要自己打开wifi的解决问题记录"></a>神舟笔记本每次开机都要自己打开wifi的解决问题记录</h1><p>试了好多<code>linux</code>操作系统以后,最终回到了起点,还是<code>manjaro</code>,但是现在发现,每次关机,开机以后都没有wifi,然后我每次都是<code>restart</code>来解决,终于,我决定不忍了,把这’最后一个’问题解决掉</p>
<h2 id="锁定现象"><a href="#锁定现象" class="headerlink" title="锁定现象"></a>锁定现象</h2><p>通过关机开机,重新启动我发现,关机开机以后就没有wifi,重新启动就有wifi,kde的networks面板显示<code>wifi is deactivated</code></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>我很仔细的对比了半天日志,<code>journalctl -p err -b</code>,甚至<code>info</code><br>我也对比了,花费了大量的时间,但是却发现没有任何问题,而且通过其它的命令,我发现驱动啥的貌似都好好的,没有任何问题.看来自己的设想方向是不对的,从结果来看,真不是驱动的问题.所以,刚开始做了很多无用功</p>
<h3 id="wifi-is-deactivated"><a href="#wifi-is-deactivated" class="headerlink" title="wifi is deactivated"></a><code>wifi is deactivated</code></h3><p>仔细查看了kde的networks面板显示以后,我发现<code>wifi is deactivated</code>,搜索以后,我发现,网上有人指出这个命令<code>rfkill list</code>,如下图 <img src="/2021/07/08/%E7%A5%9E%E8%88%9F%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%AF%8F%E6%AC%A1%E5%BC%80%E6%9C%BA%E9%83%BD%E8%A6%81%E8%87%AA%E5%B7%B1%E6%89%93%E5%BC%80wifi%E7%9A%84%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/rfkill_list.png" class="" title="蓝牙和wifi的打开关闭状态"> 不过,这是个后来的截图,以前的情况是<code>Hard blocked: yes</code></p>
<h3 id="Hard-blocked"><a href="#Hard-blocked" class="headerlink" title="Hard blocked"></a><code>Hard blocked</code></h3><p>原来<code>Hard blocked</code>是硬件关闭的意思,<a href="https://askubuntu.com/questions/1325028/wifi-gets-hard-blocked-on-ubuntu-20-04-2-hp-15-series" title="askubuntu的详尽解释" target="">askubuntu的详尽解释</a>,硬件关闭应该意味着软件无法打开,除了bios保存状态可以读取以外还原以外.里面的硬件图片,让我看看我的电脑,果然看到了fn的快捷键里面有wifi的标志,原来是wifi真的被硬件关闭了 <img src="/2021/07/08/%E7%A5%9E%E8%88%9F%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%AF%8F%E6%AC%A1%E5%BC%80%E6%9C%BA%E9%83%BD%E8%A6%81%E8%87%AA%E5%B7%B1%E6%89%93%E5%BC%80wifi%E7%9A%84%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/hard_block.png" class="" title="硬件关闭的例子"></p>
<h3 id="真的要每次开机手动打开wifi吗"><a href="#真的要每次开机手动打开wifi吗" class="headerlink" title="真的要每次开机手动打开wifi吗"></a>真的要每次开机手动打开wifi吗</h3><p>我记得我前几天安装manjaro的时候,出了点问题,所以修改了bios,以前的时候,也用的<code>kali</code><br>,也没遇到过这种问题,我决定去bios看一下,看看能不能从bios打开,进去看了以后,我就发现了我前几天修改的设置<code>cold boot keep status</code>,也就是冷启动的时候,仍然保持硬件状态,我重新<code>enabled</code><br>以后,结果开机以后,发现wifi直接就连上了</p>
<h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>前几天修改bios,把<code>cold boot keep status</code>禁用了,导致wifi的状态不能保存,然后一旦冷启动,就需要重新打开,不是<code>manjaro</code>的锅</p>
<h3 id="新知识-冷启动和热启动"><a href="#新知识-冷启动和热启动" class="headerlink" title="新知识,冷启动和热启动"></a>新知识,冷启动和热启动</h3><p>重启分为冷启动和热启动,冷启动,关机以后的开机,自检然后进入系统,热启动就是重启,关机了以后,不自检,而且保存电脑本来的硬件状态,直接启动,所以说,重启和关机开机还是有些区别的.例如,有些时候,装了一些系统软件以后,比如virtualbox或者系统更新,都会说,重新启动才能生效,这里的重新启动,有时候甚至必须是重新启动,关机再开机是不行的,所以,重新启动和关机开机真不是一码事</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>以后出了问题,先看现象再搜索,看看大家都是怎么解决的,才能更快的找到答案,自己猜猜对了还好,猜不对就是浪费时间</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>自建服务器远程连接rustDesk</title>
    <url>/2022/09/09/%E8%87%AA%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5rustDesk/</url>
    <content><![CDATA[<h1 id="自建服务器远程连接rustDesk"><a href="#自建服务器远程连接rustDesk" class="headerlink" title="自建服务器远程连接rustDesk"></a>自建服务器远程连接rustDesk</h1><h2 id="为什么需要自建服务器远程连接"><a href="#为什么需要自建服务器远程连接" class="headerlink" title="为什么需要自建服务器远程连接"></a>为什么需要自建服务器远程连接</h2><ol>
<li>当你们公司封了远程连接工具的时候</li>
<li>当你的远程连接工具速度不快的时候</li>
<li>当你的远程连接工具不是会员的时候</li>
</ol>
<h2 id="自建服务器的成本如何解决"><a href="#自建服务器的成本如何解决" class="headerlink" title="自建服务器的成本如何解决"></a>自建服务器的成本如何解决</h2><p>rustDesk对ECS要求极低,1核0.5g跑起来,就跟没跑一样</p>
<ol>
<li>选一个配置最低的还是共享的ECS</li>
<li>选择按量付费</li>
<li>选择费用最低的云盘(20g一个月才7元)</li>
<li>不用的时候关掉服务器,随用随开,关机的时候,选择节省停机类似的模式,可以做到关机不付费,但是云盘一直会收钱,不过可以做到很低</li>
</ol>
<h2 id="rustDesk如何自建服务器"><a href="#rustDesk如何自建服务器" class="headerlink" title="rustDesk如何自建服务器"></a>rustDesk如何自建服务器</h2><p>自己去官网看,就是下载两个文件,启动即可</p>
<h2 id="阿里云自建服务器指南-1小时不到1毛钱"><a href="#阿里云自建服务器指南-1小时不到1毛钱" class="headerlink" title="阿里云自建服务器指南,1小时不到1毛钱"></a>阿里云自建服务器指南,1小时不到1毛钱</h2><img src="/2022/09/09/%E8%87%AA%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5rustDesk/%E6%8C%89%E9%87%8F%E4%BB%98%E8%B4%B9.png" class="" title="按量付费">
<img src="/2022/09/09/%E8%87%AA%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5rustDesk/ECS%E5%AE%9E%E4%BE%8B.png" class="" title="ECS实例">
<img src="/2022/09/09/%E8%87%AA%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5rustDesk/%E9%95%9C%E5%83%8F%E5%92%8C%E5%AD%98%E5%82%A8.png" class="" title="镜像和存储">
<img src="/2022/09/09/%E8%87%AA%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5rustDesk/%E6%8C%89%E9%87%8F%E4%BD%BF%E7%94%A8.png" class="" title="按量使用">
<img src="/2022/09/09/%E8%87%AA%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5rustDesk/%E8%B4%B9%E7%94%A8%E7%BB%9F%E8%AE%A1.png" class="" title="费用统计">

<p>阿里云有自己的app,创建好以后,可以设置成开机自动启动,用完关掉,一定要确认是<strong>节省停机模式</strong>,这样只有20g的云盘还在用,一个月才7块钱,然后cpu和内存,带宽还有<br>公网ip都释放了,不要掏钱,虽然带宽拉满,100Mbps,但是1G流量是0.8元,其实一个小时后用不了多少流量的,还是花不了多少钱的,折合算下来,其实一个小时不到1毛钱,而且你还随用随关,<br>基本上非常nice</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>远程连接</tag>
        <tag>rustDesk</tag>
      </tags>
  </entry>
  <entry>
    <title>流程编排漫谈</title>
    <url>/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/</url>
    <content><![CDATA[<h1 id="流程编排漫谈"><a href="#流程编排漫谈" class="headerlink" title="流程编排漫谈"></a>流程编排漫谈</h1><p>讲述流程编排的概念,分类,以及传统的流程引擎代表flowable</p>
<h2 id="流程编排的使用场景"><a href="#流程编排的使用场景" class="headerlink" title="流程编排的使用场景"></a>流程编排的使用场景</h2><p>使用到流程编排的场景,大体都是复杂多变的,而且需要动态的执行,如果使用硬编码来开发,代码需要经常修改,而且如果代码耦合严重,代码的可维护性也非常差,<br>那么代码修改以后,出错的概率大大增加,常见的场景如下</p>
<ol>
<li>oa,企业办公场景</li>
<li>电商算促销</li>
<li>etl清洗</li>
<li>规则引擎</li>
<li>微服务编排</li>
<li>其余复杂的流程场景,适合使用责任链的设计模式的场景</li>
</ol>
<h2 id="流程编排定义"><a href="#流程编排定义" class="headerlink" title="流程编排定义"></a>流程编排定义</h2><p>设计好的流程,在流程引擎的驱动下,按照设计,一个个组件的执行动态执行下去,可以通过上下文共享数据</p>
<ol>
<li>流程定义,定义一个流程如何执行</li>
<li>流程组件,流程执行的一个个节点</li>
<li>流程上下文,组件之间共享数据的机制</li>
</ol>
<h2 id="流程编排和服务编排"><a href="#流程编排和服务编排" class="headerlink" title="流程编排和服务编排"></a>流程编排和服务编排</h2><p>现在的流程编排一般分为传统的流程编排,比较学院派,以BPMN为主,典型的框架就是activity&#x2F;Camunda&#x2F;flowable,还有的就是一些比较冷门,或者没那么出名的框架,弱点的甚至是流线型的<br>流程定义,强大的就是DAG的流程定义,DAG系的相对功能更强大  </p>
<p>这面这张图展示了bpmn的三兄弟,有篇文章对三兄弟做了相对比较全面的对比<a href="https://www.ithere.net/article/1454000794869297153" title="三兄弟" target="">三兄弟</a></p>
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/threeBro.jpg" class="" title="三兄弟">
<p>总结下来就是目前flowable更易用,功能比较强大,但是Camunda也很有前途</p>
<p>随便云的兴起和云原生的兴起,服务编排的概念兴起,所以服务编排,就是编排微服务,微服务编排的常见的有三种方式</p>
<ol>
<li>Orchestration（编制）,就是有个流程引擎,然后控制各个服务,中心化管理,动态管理</li>
<li>Choreography（编排）,去中心化管理,用消息连接,节点之间对等,相对动态管理</li>
<li>api网关,用网关来聚合各种服务,类似编制,但是切入点不一样,具体看实现,也可以硬编码,也可以使用流程的动态管理</li>
</ol>
<h2 id="流程编排与AOP"><a href="#流程编排与AOP" class="headerlink" title="流程编排与AOP"></a>流程编排与AOP</h2><p>切面编程的思维,在如今非常常见,在spring中,随便一个方法可能有好多个切面,各种proxy,但是切面目前针对的都是方法级别,有方法,才能有切面,但是流程编排,可以随意的<br>前后添加组件,比如本来某个流程增加了一个步骤,那么就可以增加一个组件,然后插入其中,等于说,可以是无限扩展,所有,从某种程度来说,流程编排是切面的升级版,<br>流程编排通过上下文,让程序拥有了无限扩展的能力,而且随便可以方便的配置可视化的界面,可视化监控业务</p>
<h2 id="初识BPMN"><a href="#初识BPMN" class="headerlink" title="初识BPMN"></a>初识BPMN</h2><p>BPMN,业务流程模型和标记法（BPMN, Business Process Model and Notation）,维基百科的描述就很不错,这里摘要一下</p>
<p>一些流程图的示例</p>
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-AProcesswithNormalFlow.jpg" class="" title="带正常流的流程">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-DiscussionCycle.jpg" class="" title="讨论">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-E-MailVotingProcess.jpg" class="" title="电子邮件的投票流程">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-CollectVotes.jpg" class="" title="采集投票">

<h3 id="bpmn要素"><a href="#bpmn要素" class="headerlink" title="bpmn要素"></a>bpmn要素</h3><p>BPMN用很小一套图形要素做简单的图来建模,这将令业务用户与开发者一样容易理解其中的过程和流.它的四种基本要素如下：</p>
<ol>
<li>流对象（Flow Object）<br>事件（Events）,活动（Activities）,网关（Gateways）</li>
<li>连接对象（Connecting Objects）<br>顺序流（Sequence Flow）,消息流（Message Flow）,关联（Association）</li>
<li>泳道（Swimlanes）<br>池（Pool）,道（Lane）</li>
<li>器物（Artifacts&#x2F;Artefacts）<br>数据对象（Data Object）,组（Group）,注释（Annotation）</li>
</ol>
<h3 id="流对象与连接对象"><a href="#流对象与连接对象" class="headerlink" title="流对象与连接对象"></a>流对象与连接对象</h3><p>这些对象都是实际需要执行的对象,有真实的业务含义和代码执行</p>
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-Event.jpg" class="" title="事件Event">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-Activity.jpg" class="" title="活动activity">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-Gateway.jpg" class="" title="关口gateway">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-Connecting.png" class="" title="连接Connections">

<p>流对象（Flow Objects）是BPMN的主要描述对象,由三种核心要素（事件、活动、关口）组成.</p>
<h4 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h4><p>“事件”（Event）以圆环表示,指发生的事情（区分于“活动”代表所做的事情）.圆环中的图标代表事件的类型（例如：信封为消息,时钟为时间）.事件也被分为“捕获”（Catching,例如捕获输入的消息而开始一个流程）或“抛出”（Throwing,例如在流程结束抛出消息）.</p>
<ol>
<li>开始事件（Start event）<br>作为流程的触发器；以细单线标明,并且只能“捕获”（Catch）,所以它显示为空心（轮廓）的图标.</li>
<li>结束事件（End event）<br>表现流程的结果；以粗单线标明,且只能“抛出”（Throw）,所以显示为实心图标.</li>
<li>中间事件（Intermediate event）<br>表现发生在开始和结束事件之间的事；以双线标明,可以是“抛出”或“捕获”（相应采用实心或空心图标）.例如,一任务流到一事件,抛出一个消息到另一个池,然后由下一个事件守候,捕获其回应.</li>
</ol>
<h4 id="活动（Activity）"><a href="#活动（Activity）" class="headerlink" title="活动（Activity）"></a>活动（Activity）</h4><p>“活动”（Activity）用圆角矩形表示,并描述必需做的工作的种类.</p>
<ol>
<li>任务（Task）<br>任务代表单一工作单元,它不会或不能被分解为更深层次上的业务流程细节,而不包含操作程序步骤的图示（此非BPMN的目的）.</li>
<li>子流程（Sub-process）<br>用于隐藏或显露深层业务流程细节——收起时,在矩形底部用加号标明子流程；展开时,在矩形内显示全部的流对象、连接对象及器物.<br>子流程自含开始及结束事件,来自“父”流程的顺序流不可跨过其边框.</li>
<li>事务（Transaction）<br>子流程的一种形式,其所包含的全部活动必须作为一个整体对待,即它们必须完全结束以满足目标,其中任何一个失败就必须全部偿还（撤回）.事务作为扩展的子流程,用双线环绕.</li>
</ol>
<h4 id="关口（Gateway）"><a href="#关口（Gateway）" class="headerlink" title="关口（Gateway）"></a>关口（Gateway）</h4><p>“关口”（Gateway）用菱形表示,基于所示条件决定路径的分流与合并.<br>“流对象”通过“连接对象”（Connecting objects）互相连接.连接对象包括三个类型（顺序、消息、关联）：</p>
<ol>
<li>顺序流（Sequence Flow）<br>“顺序流”用实心线和箭头表示,显示活动进行的顺序.“顺序流”还可以在开始端带有符号,以小菱形标明其中一些发自活动的“条件流”（conditional flow）,同时以对角斜线标明发自活动或决定,带条件流的“默认流”（default flow）.</li>
<li>消息流（Message Flow）<br>“消息流”用虚线表示,起始端有一个空心圆圈,终端是一个空心箭头.它告诉我们哪些消息流跨过组织的边界（即介于池之间）.消息流不可用于在同一个池中连接活动或事件.</li>
<li>关联（Association）<br>“关联”（Association）用点线表示.它用于创建器物或文本到流对象的联系,并且可以用空心箭头标明某种方向性（指向器物表示结果,源自器物表示输入,同时出现则表示读和更新）.当器物或文本联系到顺序或消息流时,关联无需标明方向（那些流已经显示了方向）.</li>
</ol>
<h3 id="泳道与器物"><a href="#泳道与器物" class="headerlink" title="泳道与器物"></a>泳道与器物</h3><p>这些对象不可执行,可用于业务流程的可读性和分析,整体类似代码的注释<br>流程引擎框架在实现的时候,这些可读性的组件,都是选择性的实现,未必都有,比如flowable,可视化就没有实现全</p>
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-Swimlanes.jpg" class="" title="泳道Swimlanes">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-Data.jpg" class="" title="数据对象DataObjects">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-Group.jpg" class="" title="组Groups">
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/BPMN-Annotation.png" class="" title="注释Annotation">

<h4 id="泳道（Swimlanes）"><a href="#泳道（Swimlanes）" class="headerlink" title="泳道（Swimlanes）"></a>泳道（Swimlanes）</h4><p>从视觉上对活动加以组织或分类的机制.它基于交叉功能流程图基础,在BPMN中有两种类型：</p>
<ol>
<li>池（Pool）<br>表示流程中的主要参与者,典型地,用来分开不同的组织.一个池可容纳一个或多个道（像真实的泳池一样）.当池为展开的（显示出内部细节）,绘做大的矩形；若为收起的（隐藏起内部细节）,绘做沿着图的长或宽伸展的空的矩形.</li>
<li>道（Lane）<br>在池中,用于活动按职能译注3或角色归类.绘做按池的长或宽展开的矩形.道包含流对象、连接对象和器物.</li>
</ol>
<h4 id="器物（Artifacts）"><a href="#器物（Artifacts）" class="headerlink" title="器物（Artifacts）"></a>器物（Artifacts）</h4><p>开发者可以带给模型／图更多的信息,通过这一方式,使模型／图更可读.预定的三种器物如下：</p>
<ol>
<li>数据对象（Data Objects）<br>“数据对象”向读者显示在活动中需要或产生哪些数据.</li>
<li>组（Group）<br>组表现为虚线的圆角矩形.组用来将不同的活动分组,但不影响图中的流.</li>
<li>注释（Annotation）<br>注释为模型／图的读者增加可理解性.</li>
</ol>
<h2 id="flowable简介"><a href="#flowable简介" class="headerlink" title="flowable简介"></a>flowable简介</h2><p>flowable功能比较强大,而且国内关注的人比较多,用的人也相对比较多,出了错,还可以搜到答案,所以,这里以flowable为例,介绍bpmn的典型框架,但是Flowable从6.4.1版本开始大力发展其商业版产品,<br>开源版本也不在及时维护.部分功能已经不再开源版发布,比如表单生成器（表单引擎）、历史数据同步至其他数据源、es等等.</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>一个简单的流程示例</p>
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/pur1Service-bpmn.png" class="" title="flowable流程设计">

<p>对应的bpmn20.xml,<code>bpmndi:BPMNDiagram</code>是原始的图形信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> <span class="attr">exporter</span>=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> <span class="attr">exporterVersion</span>=<span class="string">&quot;6.7.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;pure1Service&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pure1Service&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;开始&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-6F3577E0-2694-4732-A470-58E4074D0514&quot;</span> <span class="attr">name</span>=<span class="string">&quot;服务1&quot;</span> <span class="attr">flowable:async</span>=<span class="string">&quot;true&quot;</span> <span class="attr">flowable:class</span>=<span class="string">&quot;com.vzoom.flowable.flowableservice.CommonService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">serviceTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-954B5B92-6338-4DBB-BA2F-A66816972875&quot;</span> <span class="attr">name</span>=<span class="string">&quot;服务2&quot;</span> <span class="attr">flowable:async</span>=<span class="string">&quot;true&quot;</span> <span class="attr">flowable:class</span>=<span class="string">&quot;com.vzoom.flowable.flowableservice.CommonService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">serviceTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-3A06C8B5-0ED9-4945-A5F5-9E3E498474F4&quot;</span> <span class="attr">name</span>=<span class="string">&quot;服务3&quot;</span> <span class="attr">flowable:async</span>=<span class="string">&quot;true&quot;</span> <span class="attr">flowable:class</span>=<span class="string">&quot;com.vzoom.flowable.flowableservice.CommonService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">serviceTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;sid-E70A0CBA-2FF8-4F27-A3D1-97BD51F1E526&quot;</span> <span class="attr">name</span>=<span class="string">&quot;结束&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-00C32123-9AA2-4420-AEBD-D21C2AE62870&quot;</span> <span class="attr">name</span>=<span class="string">&quot;线1&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-6F3577E0-2694-4732-A470-58E4074D0514&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-65068C9A-EC24-499C-A287-CD019FF1C15D&quot;</span> <span class="attr">name</span>=<span class="string">&quot;线2&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-6F3577E0-2694-4732-A470-58E4074D0514&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-954B5B92-6338-4DBB-BA2F-A66816972875&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-582D7F57-14AE-40ED-A1C1-B6832959D4CA&quot;</span> <span class="attr">name</span>=<span class="string">&quot;线3&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-954B5B92-6338-4DBB-BA2F-A66816972875&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-3A06C8B5-0ED9-4945-A5F5-9E3E498474F4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-40FA984E-4697-4A9B-B5D1-39F30B5EE97B&quot;</span> <span class="attr">name</span>=<span class="string">&quot;用户任务1&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-B338251C-C581-4916-BA5D-F7BC94563232&quot;</span> <span class="attr">name</span>=<span class="string">&quot;线4&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-3A06C8B5-0ED9-4945-A5F5-9E3E498474F4&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-40FA984E-4697-4A9B-B5D1-39F30B5EE97B&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-8E49C236-A4AE-481A-B4E7-5F430477C0B4&quot;</span> <span class="attr">name</span>=<span class="string">&quot;线5&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-40FA984E-4697-4A9B-B5D1-39F30B5EE97B&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-E70A0CBA-2FF8-4F27-A3D1-97BD51F1E526&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_pure1Service&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;pure1Service&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNPlane_pure1Service&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;163.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-6F3577E0-2694-4732-A470-58E4074D0514&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-6F3577E0-2694-4732-A470-58E4074D0514&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;240.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;138.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-954B5B92-6338-4DBB-BA2F-A66816972875&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-954B5B92-6338-4DBB-BA2F-A66816972875&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;405.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;138.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-3A06C8B5-0ED9-4945-A5F5-9E3E498474F4&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-3A06C8B5-0ED9-4945-A5F5-9E3E498474F4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;555.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;138.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-E70A0CBA-2FF8-4F27-A3D1-97BD51F1E526&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-E70A0CBA-2FF8-4F27-A3D1-97BD51F1E526&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;990.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;164.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-40FA984E-4697-4A9B-B5D1-39F30B5EE97B&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-40FA984E-4697-4A9B-B5D1-39F30B5EE97B&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;735.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;138.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-00C32123-9AA2-4420-AEBD-D21C2AE62870&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-00C32123-9AA2-4420-AEBD-D21C2AE62870&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;129.94999940317362&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;239.99999999993753&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-8E49C236-A4AE-481A-B4E7-5F430477C0B4&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-8E49C236-A4AE-481A-B4E7-5F430477C0B4&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;834.9499999999925&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;990.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-B338251C-C581-4916-BA5D-F7BC94563232&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-B338251C-C581-4916-BA5D-F7BC94563232&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;654.9499999999431&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;734.9999999998699&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-582D7F57-14AE-40ED-A1C1-B6832959D4CA&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-582D7F57-14AE-40ED-A1C1-B6832959D4CA&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;504.9499999999581&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;554.9999999999363&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-65068C9A-EC24-499C-A287-CD019FF1C15D&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-65068C9A-EC24-499C-A287-CD019FF1C15D&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;339.9499999998897&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;404.99999999998465&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="api简介"><a href="#api简介" class="headerlink" title="api简介"></a>api简介</h3><ol>
<li>执行流程<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.startProcessInstanceByKey(<span class="string">&quot;callActivity&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>部署流程<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DeploymentBuilder</span> <span class="variable">deployment</span> <span class="operator">=</span> repositoryService.createDeployment();</span><br><span class="line"><span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> deployment.name(<span class="string">&quot;asyncErrorService1&quot;</span>).addString(UUID.randomUUID() + <span class="string">&quot;.bpmn20.xml&quot;</span>, <span class="string">&quot;xmlContext&quot;</span>).deploy(); <span class="comment">//必须以.bpmn20.xml结尾</span></span><br><span class="line">List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().deploymentId(deploy.getId()).list();</span><br><span class="line"><span class="type">BpmnModel</span> <span class="variable">bpmnModel</span> <span class="operator">=</span> repositoryService.getBpmnModel(list.get(<span class="number">0</span>).getId());</span><br></pre></td></tr></table></figure></li>
<li>流程回退<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().taskAssignee(<span class="string">&quot;signUser&quot;</span>).singleResult();</span><br><span class="line"> runtimeService.createChangeActivityStateBuilder().processInstanceId(task.getProcessInstanceId()).moveActivityIdTo(task.getTaskDefinitionKey(),<span class="string">&quot;task1&quot;</span>).changeState();</span><br></pre></td></tr></table></figure></li>
<li>流程重跑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Job&gt; list = managementService.createDeadLetterJobQuery().processInstanceId(hiProcinstId).list();</span><br><span class="line"><span class="keyword">for</span> (Job job : list) &#123;</span><br><span class="line">    managementService.moveDeadLetterJobToExecutableJob(job.getId(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>flowable的翻译文档有<a href="https://tkjohn.github.io/flowable-userguide/#uiAppInstallation" title="flowable中文翻译文档" target="">flowable中文文档</a>,<br>这个不是最新版的,官网的最新文档是<a href="https://www.flowable.com/open-source/docs/bpmn/ch07a-BPMN-Introduction" title="flowable官网文档" target="">flowable官网文档</a></p>
<ol>
<li>用户任务,可以认为是留白,流程跑到用户任务会阻塞,然后什么也不做,自己调用api完成以后,才能执行以后的流程</li>
<li>服务任务需要继承接口<code>org.flowable.engine.delegate.JavaDelegate</code>,和spring集成的时候,可以是spring的bean,需要这样设置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serviceTask.setImplementationType(BpmnXMLConstants.ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION); <span class="comment">//ATTRIBUTE_TASK_SERVICE_DELEGATEEXPRESSION是&quot;delegateExpression&quot;</span></span><br><span class="line">serviceTask.setImplementation(<span class="string">&quot;$&#123;&quot;</span> + nodeCode + <span class="string">&#x27;&#125;&#x27;</span>); <span class="comment">//nodeCode就是bean 的 name</span></span><br></pre></td></tr></table></figure></li>
<li>服务任务抛出BpmnError的时候,才能使用重跑的功能,所以,一定要有个父类,去捕获异常,重新抛出成BpmnError</li>
<li>流程默认有spring的事务,如果不想要使用事务,需要jdbc的方法上添加<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br></pre></td></tr></table></figure></li>
<li>任务最好设置成异步,否则失败了以后,流程没有记录</li>
<li>使用的时候,有执行监听器,类似于切面,分为前置后置等等,用户任务和服务任务的监听器不能共用,需要额外设置,可以参考 <a href="https://blog.csdn.net/mccand1234/article/details/115462870" title="执行监听器与任务监听器的基本使用" target="">监听器</a></li>
</ol>
<h2 id="非典型性流程编排"><a href="#非典型性流程编排" class="headerlink" title="非典型性流程编排"></a>非典型性流程编排</h2><h3 id="分布式方向"><a href="#分布式方向" class="headerlink" title="分布式方向"></a>分布式方向</h3><p>现在都是微服务时代了,集群已经是一种常见的现象,所以分布式服务编排也是一种常见的需求 <a href="https://developer.aliyun.com/article/609299" title="基于DAG的分布式任务调度平台-Maat" target="">阿里的maat</a></p>
<h4 id="为什么要做Maat"><a href="#为什么要做Maat" class="headerlink" title="为什么要做Maat"></a>为什么要做Maat</h4><p>我们在项目的开发过程中，经常遇到一些流程化调度的需求，如上线发布流程、分析任务流程等。对于这些流程化的调度任务，我们尝试过自己开发了一套流程调度系统，也尝试过接入集团的工作流，但难免会遇到一些问题：</p>
<ol>
<li>业务代码和调度代码耦合严重，修改流程基本需要入侵到代码级别</li>
<li>对于定时触发的任务流程，没有一个统一管控的系统</li>
<li>多分支的复杂流程不能很好支持</li>
<li>缺少可视化的UI，不能很好追踪流程进度</li>
</ol>
<h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>Maat核心模块完成了任务调度的整个流程。核心模块的每个节点都独立运行在机器上，启动上互相不依赖，所有消息通信通过DB（数据库）和MQ（消息队列）完成。</p>
<h5 id="Web-Api-Service"><a href="#Web-Api-Service" class="headerlink" title="Web Api Service"></a>Web Api Service</h5><p>Web Api Service提供了丰富的与外部交互的Api，包括任务增删改、历史任务状态、任务状态修改、任务的触发、任务的重试等接口。<br>另外原生airflow提供的web展示功能也是由该角色完成。</p>
<h5 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h5><p>scheduler是maat关键角色，它决定了所有开启运行的流程何时可以触发一次运行，也决定一次任务运行中，哪些节点可以被执行。被判定执行的节点会被scheduler通过mq发送给worker执行。</p>
<p>随着任务的增多，单一的scheduler负载过高导致调度周期增长，为了减轻scheduler的压力，maat将scheduler按照队列拆分。不同队列的任务有独立的scheduler负责调度，将任务分发给对应队列的worker执行。</p>
<p>目前每个队列仅有一个scheduler负责调度，之后会改造为每个队列多scheduler的实现方式。</p>
<h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h5><p>worker为具体执行任务的角色，worker会接受scheduler发出的任务，在worker上执行节点中描述的具体任务。worker角色有多个，任务会在任意一个对等的worker上机器，当worker资源不足时，可以动态扩容。</p>
<p>由于不同队列任务所需的基础环境不同，如Python、Java、Hadoop、zk等，不同队列的worker角色启动参数有配置上的差异，不同队列的worker启动时会按照配置中描述的资源完成部署安装。</p>
<p>worker上任务完成后会回写db，scheduler察觉到当前任务状态变化后会继续任务的调度。</p>
<h5 id="Distributers"><a href="#Distributers" class="headerlink" title="Distributers"></a>Distributers</h5><p>任务分发层负责将scheduler需要调度的任务发送到指定的Worker上。</p>
<p>MQ：原生Airflow使用MQ完成scheduler到worker的消息传递，底层由celery+Rabbitmq实现。scheduler将需要运行的任务发送到MQ中，发送到MQ中包含任务对应的队列信息。worker从MQ获取消息时，仅获取相应队列任务，拉取到对应worker上执行。MQ在maat中以rabbitmq实现，MQ和其他角色一样，也是独立部署的。</p>
<p>FaaS：FaaS（Function as a Service）是基于搜索生态实现的ServerLess框架，Maat将其作为执行器。Maat的所有任务都抽象成function，任务执行时则调用相应的function，完成后返回任务状态。目前已完成与FaaS的初步对接，期望未来能基于FaaS做更多优化，如：多样化的任务执行方式，可以将轻量级的任务函数化，将重量级的任务服务化；任务资源动态调整，甚至某些任务可以执行时分配资源，完成后即释放。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>分布式场景中,Scheduler负责调度,worker负责执行,然后Distributers负责将scheduler需要调度的任务发送到指定的Worker上,然后提供web api来做任务的管理</p>
<h3 id="DAG方向"><a href="#DAG方向" class="headerlink" title="DAG方向"></a>DAG方向</h3><p>bpmn比较全面,比较重,对于etl场景来说,就过于复杂了,对于etl场景,需要的就是一个简单的流程引擎,airflow,就很适合做etl,而且使用DAG作为定义,<br>airflow的文档 <a href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/dags.html#" title="airflow的DAG" target="">DAG方向</a></p>
<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/airflow-dag.png" class="" title="airflow的DAG">

<h3 id="低代码方向"><a href="#低代码方向" class="headerlink" title="低代码方向"></a>低代码方向</h3><p>低代码平台中,需要一个流程引擎来动态的执行代码</p>
<ol>
<li>低代码平台中的oa需要动态的设置流程,其中就需要流程引擎<img src="/2022/10/08/%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92%E6%BC%AB%E8%B0%88/oa-bpmn.png" class="" title="oa的流程引擎"></li>
<li>低代码平台,组件化开发也需要一个流程引擎来驱动代码</li>
<li>服务编排,微服务的服务编排,针对微服务的接口调用场景,提供专用的节点,和一些特定的功能,来满足微服务的编排,比如提供参数化节点来对应api</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>流程编排,是一个很好的实践,现在的世界,信息技术是基石,软件的复杂度非常高,流程编排是一个很好的方向,来面对复杂多变且易出错的需求,而且几乎所有的场景都适合流程编排</p>
]]></content>
      <categories>
        <category>流程编排</category>
      </categories>
      <tags>
        <tag>概念介绍</tag>
        <tag>流程编排</tag>
      </tags>
  </entry>
</search>
